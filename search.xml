<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软考知识点记录]]></title>
    <url>%2F2019%2F10%2F07%2F%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[软考知识点笔记 计算机组成与体系与结构数据的表示计算机接口Flynn分类法CISC与RISC流水线技术存储系统总线系统可靠性校验码]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo-Ocean主题博客搭建]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%9F%BA%E4%BA%8EHexo-Ocean%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo-Ocean主题博客搭建改动记录 本文主要是Hexo Ocean主题博客搭建过程的记录博客地址：松林羊 hexo 的基本命令hexo init [folder] ：创建一个存放网站源码的文件夹。hexo new [layout] &lt;title&gt;：新建一篇文章。layout：默认post，可以是page、draft。title：文章标题，标题包含空格的话，请使用引号括起来。hexo clean：清除缓存文件db.json和已生成的静态文件public,尤其是更换主题后hexo g：生成静态html文件hexo s：启动服务器hexo d：部署网站传送门：官方文档 下载主题源码在hexo init [folder] 的folder目录下执行： 1git clone https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean 参照主题文档进行配置Ocean 中文文档关于 Ocean 使用中的问题 文章自动添加Read More将\themes\ocean\layout\_partial\article.ejs文中的&lt;% if (post.excerpt &amp;&amp; index){ %&gt;的else部分替换为如下内容： 123456789&lt;% var br = post.content.indexOf('&lt;br&gt;') %&gt;&lt;% if(br &lt; 0 || !index) &#123; %&gt; &lt;%- post.more %&gt;&lt;% &#125; else &#123; %&gt; &lt;%- post.content.substring(0, br) %&gt;&lt;br/&gt; &lt;% if (theme.excerpt_link) &#123; %&gt; &lt;a class="article-more-link" href="&lt;%- url_for(post.path) %&gt;"&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 搜索功能不起作用? or 除开首页不能正常搜索 本地检索需要安装插件 1npm install hexo-generator-searchdb --save 另外一个问题：插件搜索函数返回的url 地址有问题 ，作者说是因为 “中文字符被URL encode了 ” 。后来我找到一个解决办法：将 [folder]/node_modules/hexo-generator-searchdb/templates/xml.ejs 文件中的： 1&lt;url&gt;&lt;%- encodeURIComponent(config.root + post.path) %&gt;&lt;/url&gt; 修改为 1&lt;url&gt;&lt;%- encodeURI(config.root + post.path) %&gt;&lt;/url&gt; 修改导航栏修改 themes/ocean/source/css/_partial/navbar.styl 文件 文章添加封面图片12345678---title: Post namedate: 2019-07-24 22:01:03photos: [ [&quot;/images/相机.jpg&quot;], // themes/ocean/source/images目录下 [&quot;https://tuchong.pstatp.com/2716763/f/531173888.jpg&quot;] ]--- 在首页只会显示第一张，详情页会按顺序显示这两张 为文章添加Gitalk评论参考：https://zhwangart.github.io/2018/12/06/Gitalk/ 在右上角或者左上角实现fork me on github选样式：GitHub Corners-1 &emsp;GitHub Corners-2然后粘贴刚才复制的代码到themes/ocean/layout/index.ejs文件中，放在&lt;div id=”landingpage”&gt;&lt;/div&gt;的第一行，并把href改为你的github地址对样式做出修改：&lt;div id=”landingpage”&gt; 修改为 &lt;div id=”landingpage” style=”position:relative;”&gt;复制的&lt;a&gt;标签添加如下样式：style=”position:absolute;left:0;top:100;z-index=1000;” 实现点击出现特效 点击桃心下载：桃心Js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。在themes/ocean/_config.yml最后一行写入： 1lovejs: true 将love.js文件放到路径/themes/ocean/source/js/src里面，然后打开\themes\ocean\layout\_partial\ after-footer.ejs文件, 在最后一行写入： 123&lt;% if (theme.lovejs)&#123; %&gt; &lt;%- js('/js/love.js') %&gt;&lt;% &#125; %&gt; 爆炸效果下载：fireworks.js&emsp;anime.min.js步骤与上面类似保存js到/themes/ocean/source/js/src，最后在\themes\ocean\layout\_partial\ after-footer.ejs文件内容未写入： 12345&lt;% if (theme.fireworks)&#123; %&gt; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;%- js('/js/anime.min.js') %&gt; &lt;%- js('/js/fireworks.js') %&gt;&lt;% &#125; %&gt; 头像旋转效果打开\themes\ocean\layout\_partial\sidebar.ejs，给&lt;div class=logo&gt;下的img加上一个id。然后参考：css + js实现图片不停旋转 鼠标悬停停止旋转然后将里面的js代码copy到一个my.js文件中（注意替换img的id），保存到/themes/ocean/source/js/src目录。然后在\themes\ocean\layout\_partial\after-footer.ejs中最后一行写入： 1&lt;%- js('/js/my.js') %&gt; 网站底部加上访问量\themes\ocean\layout\_partial\after-footer.ejs 中默认是导入了统计脚本的(busuanzi-2.3.pure.min.js ) 修改访问量统计的样式：将\themes\ocean\layout\_partial\post\busuanzi.ejs修改为： 123456789&lt;div class="powered-by"&gt; &lt;% if (is_home()) &#123; %&gt; &lt;span id="busuanzi_container_site_pv"&gt;访问量:&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;&lt;/span&gt; &lt;%&#125; %&gt; &amp;emsp;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt;访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&amp;emsp; &lt;% if (is_post()) &#123; %&gt; &lt;i class="fe fe-bookmark"&gt;&lt;/i&gt;文章访问量:&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; &lt;%&#125; %&gt;&lt;/div&gt; 添加网站字数，阅读时间统计在根目录下运行： 1npm install hexo-wordcount –save 在\themes\ocean\_config.yml主题配置文件中加入： 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 在\themes\ocean\layout\_partial\footer.ejs文件中，在&lt;ul class=”list-inline”&gt;标签后加入： 123&lt;ul class="list-inline"&gt; &lt;li&gt;全站共&lt;span class="post-count"&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt;字&lt;/li&gt;&lt;/ul&gt; 在\themes\ocean\layout\_partial\article.ejs文件中，在标签中加入： 12&amp;emsp;&lt;i class="fe fe-bar-chart"&gt;&lt;/i&gt; &lt;span class="post-count"&gt;&lt;%- wordcount(post.content) %&gt;&lt;/span&gt;字&amp;emsp;&lt;i class="fe fe-clock"&gt;&lt;/i&gt; &lt;span class="post-count"&gt;&lt;%- min2read(post.content) %&gt;&lt;/span&gt;分钟 Ocean主题的图标图标在\themes\ocean\source\css\_feathericon.styl中查找官网：feathericons 为博客加上萌萌的宠物hexo-helper-live2d在网站根目录下执行 12npm install -save hexo-helper-live2dnpm install live2d-widget-model-haruto(自己选择的萌宠模型) 在hexo的配置文件中添加： 123456789101112131415161718192021# 萌宠 live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: left hOffset: 0 vOffset: -20 mobile: show: true react: opacityDefault: 0.5 opacityOnHover: 0.2 重启服务： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 添加网站运行时间1234567891011121314151617&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("04/26/2019 15:49:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250);&lt;/script&gt; 将以上代码保存到\themes\ocean\layout\_partial\post\runtime.ejs 在\themes\ocean\layout\_partial\footer.ejs文件中，第一个&lt;ul class=”list-inline”&gt;&lt;/ul&gt;标签后加入： 123&lt;div class="float-right"&gt; &lt;%- partial('post/runtime') %&gt;&lt;/div&gt; 添加DaoVoice 在线联系首先在https://account.daocloud.io/signin &emsp;注册账号然后点击下方链接http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f之后会得到一个app_id 在主题配置文件写入： 123# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 在\themes\ocean\layout\_partial\footer.ejs中，&lt;/head&gt;前写入： 123456789&lt;% if (theme.daovoice)&#123; %&gt; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&lt;%- theme.daovoice_app_id %&gt;" &#125;); daovoice('update'); &lt;/script&gt;&lt;% &#125; %&gt; 取消文章下面的分享连接，添加本文结束去掉\themes\ocean\layout\_partial\article.ejs中的以下代码： 1&lt;a data-url="&lt;%- post.permalink %&gt;" data-id="&lt;%= post._id %&gt;" class="article-share-link"&gt;&lt;%- theme.share_text %&gt;&lt;/a&gt; 同时还可以添加本文结束 感谢阅读等说明:如在&lt;%- partial(‘post/tag’) %&gt;下面一行添加： 123&lt;% if (!index &amp;&amp; is_post()) &#123; %&gt; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------------- 本文结束&amp;nbsp;&lt;i class="fe fe-smile"&gt;&lt;/i&gt;&amp;nbsp;感谢您的阅读 -------------&lt;/div&gt;&lt;% &#125; %&gt; 博文压缩在根目录下执行： 12npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp –save 在根目录下新建gulpfile.js，写入一下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142var gulp = require('gulp');//Plugins模块获取var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');//压缩cssgulp.task('minify-css',function() &#123; return gulp.src('./public/**/*.css').pipe(minifycss()).pipe(gulp.dest('./public'));&#125;);//压缩htmlgulp.task('minify-html',function() &#123; return gulp.src('./public/**/*.html').pipe(htmlclean()).pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);//压缩js 不压缩min.jsgulp.task('minify-js',function() &#123; return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']).pipe(uglify()).pipe(gulp.dest('./public'));&#125;);//4.0以前的写法 //gulp.task('default', [// 'minify-html', 'minify-css', 'minify-js'//]);//4.0以后的写法// 执行 gulp 命令时执行的任务//gulp.task('default', gulp.parallel('minify-html', 'minify-css', 'minify-js',//function() &#123; // Do something after a, b, and c are finished.// console.log('success')//&#125;));gulp.task('default',gulp.series(gulp.parallel('minify-html','minify-css','minify-js'))); 生成博文时执行 1hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 修改文章封面图片的引入方式，同时支持相对地址与http的图片将\themes\ocean\layout\_partial\post\gallery.ejs中的&lt;% if (index){ %&gt;的上一行写入： 1&lt;% var idx = url_for(photo).indexOf('http') %&gt; 将文中两处的： 1&lt;img src="&lt;%- url_for(photo) %&gt;" itemprop="image"&gt; 修改为： 12345&lt;% if(idx &lt; 0) &#123; %&gt; &lt;img src="&lt;%- url_for(post.path)+url_for(photo).substring(1) %&gt;" itemprop="image"&gt;&lt;% &#125; else &#123; %&gt; &lt;img src="&lt;%- url_for(photo) %&gt;" itemprop="image"&gt;&lt;% &#125; %&gt; 设置封面图片不在内容详情页展示将\themes\ocean\layout\_partial\article.ejs中的 1&lt;%- partial('post/gallery') %&gt; 修改为： 123&lt;% if (index)&#123; %&gt; &lt;%- partial('post/gallery') %&gt;&lt;% &#125; %&gt; 去掉rss订阅根目录下执行： 1npm uninstall hexo-generator-feed –save 将\themes\ocean\_config.yml文件中修改为：rss: false 导航栏图表改为在文字左侧修改\themes\ocean\source\css\_partial\navbar.styl 1234567&amp;.nav-main .nav-item-link &amp;::before, i.fe display block line-height 1 &amp;::before font-family 'feathericon' 修改为： 12345678&amp;.nav-main .nav-item-link &amp;::before, i.fe // display block line-height 1 margin-right: 10px; &amp;::before font-family 'feathericon' 添加readme.md不被渲染在Hexo目录下的source根目录下添加一个, README.md。修改Hexo目录下的_config.yml。将skip_render参数的值设置上。skip_render: README.md保存退出即可。 首页视屏换成图片将\themes\ocean\layout\_partial\ocean.ejs中 1234567&lt;video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="&lt;%- theme.ocean.path %&gt;ocean.png" x5-video-player-type="h5"&gt; &lt;source src="&lt;%- theme.ocean.path %&gt;ocean.mp4" type="video/mp4"&gt; &lt;source src="&lt;%- theme.ocean.path %&gt;ocean.ogv" type="video/ogg"&gt; &lt;source src="&lt;%- theme.ocean.path %&gt;ocean.webm" type="video/webm"&gt; &lt;p&gt;Your user agent does not support the HTML5 Video element.&lt;/p&gt;&lt;/video&gt; 修改为： 1&lt;img src="&lt;%- theme.ocean.path %&gt;ocean.png"&gt; 去掉首页视频或图片去掉themes/ocean/layout/index.ejs中的 1&lt;%- partial('_partial/ocean') %&gt; is_home()、is_post() 函数判断不正确将\themes\ocean\layout\layout.ejs中 1&lt;%- partial('_partial/footer', null, &#123;cache: !config.relative_link&#125;) %&gt; 修改为 1&lt;%- partial('_partial/footer', null, &#123;cache: config.relative_link&#125;) %&gt; 就是将partial中的cache设置为false。参考：is_home()、is_post() 函数判断不正确 视频 or 图片只在pc端显示，不在移动端显示修改themes\ocean\source\css_partial\layou.styl文件 12345// Media Query@media (min-width: 768px) .jumbotron margin-bottom 6rem display block //此处为新增。设备宽度大于等于768像素时显示视频or图片 在文件末尾新增 123@media (max-width: 768px) .jumbotron display none // 设备宽度小于等于768像素时不显示视频or图片 此时会发现移动端左上角有点空旷，则进行如下修改修改themes\ocean\layout_partial\archive.ejs文件 12345var title = '';var mobile_title = "松林羊 Blog"; // 此处为新增...&lt;h1 class="page-type-title pc"&gt;&lt;%- title %&gt;&lt;/h1&gt; // 新增类名为pc的样式&lt;h1 class="page-type-title mobile"&gt;&lt;%- mobile_title %&gt;&lt;/h1&gt; // 此处为新增 修改themes\ocean\source\css_partial\archive.styl文件 123456789101112131415.page-type-title margin 0 padding 3rem 0 // 以下内容为新增 &amp;.pc @media screen and (max-width: 768px) display none @media screen and (min-width: 768px) display block &amp;.mobile @media screen and (max-width: 768px) display block font-family 'STXingkai' @media screen and (min-width: 768px) display none 配置fancybox展示文章图集在themes\ocean\layout\_partial\after-footer.ejs文件末尾加入如下代码 12345678&lt;% if (is_post())&#123; %&gt;&lt;script&gt;// 使用fancybox来显示post图片集(#andus-head-img为头像id)$('img:not(#andus-head-img)').each(function() &#123; $(this).wrap('&lt;a class="fancybox" data-fancybox="gallery" href="' + $(this).prop("src") + '"&gt;&lt;/a&gt;'); &#125;)&lt;/script&gt;&lt;% &#125; %&gt; 记录(自用)12&lt;%- page.content.substring(0,tips) %&gt; 显示html的样式结果&lt;%= page.content.substring(0,tips) %&gt;显示html源代码]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>ocean</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office 2019 专业增强版 在线安装+激活]]></title>
    <url>%2F2019%2F08%2F14%2Foffice-2019-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%88-%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85-%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[最新office2019,在线安装激活教程 注明：软件来自网络 1.在线安装+激活只激活，直接看第二点 链接：https://pan.baidu.com/s/1kGxTRLzjbdz_LRRBgCS3pA提取码：oqmp失效请留言 如图 2.只激活传送门：https://blog.csdn.net/bluewn/article/details/90480847]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(Ubuntu 18.04 LTS)使用记录]]></title>
    <url>%2F2019%2F07%2F21%2FLinux-Ubuntu-18-04-LTS-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一篇关于Ubuntu的使用记录，包含分区，双系统安装教程，常用软件安装及配置… 系统：ubuntu18.04 LTS 置顶安利一个网站：https://www.lulinux.com/deepin-wine-QQ、百度网盘、WPS等应用解决方案：https://www.lulinux.com/archives/1319deepin软件仓库：http://packages.deepin.com/deepin/pool/non-free/双系统的安装：Windows10+Ubuntu18.04+双硬盘(SSD+HDD)安装双系统 1. 分区与挂载Linux新建分区https://blog.csdn.net/github_33809414/article/details/85208666/usr目录挂载到新分区https://blog.csdn.net/github_33809414/article/details/85207300/var目录挂载到新分区https://blog.csdn.net/github_33809414/article/details/85221274开机自动挂载https://blog.csdn.net/qwfys200/article/details/79737780 2. 连接校园网https://blog.csdn.net/github_33809414/article/details/85054911 3. 替换阿里源https://www.cnblogs.com/lyon2014/p/4715379.html 4. 安装搜狗输入法https://blog.csdn.net/fx_yzjy101/article/details/80243710重启后，搜狗拼音输入法候选栏无法显示中文（乱码）https://my.oschina.net/i1sfish/blog/1822964中英文无法切换我的解决方法是: fcitx 设置中加入英文键盘即可 5. firefox浏览器安装flashhttps://blog.csdn.net/weixin_40522162/article/details/80287296 6.安装百度云，失败，参考置顶https://jingyan.baidu.com/article/a24b33cdc99c1e19fe002b93.htmlhttps://blog.csdn.net/cheng_ku/article/details/80286172 7. 安装crossover，建议不要折腾windows应用很卡，还要收费，放弃https://my.oschina.net/u/3275937/blog/2995386https://blog.csdn.net/valecalida/article/details/81084210 8. 安装vmware!!不要升级内核，就用默认的(4.15.0-46-generic)。否则vmware不能运行。最终安装成功版本VMware Workstation Pro 15.0.2 for Linux，参照的第二个链接https://www.jianshu.com/p/5fc43bbbac5ahttps://blog.csdn.net/wy_bk/article/details/80017140需要安装gcc7https://blog.csdn.net/weixin_35762621/article/details/80336291问题：/vmware/Ubuntu.vmdk' or one of the snapshot disks it depends onhttps://blog.csdn.net/guomutian911/article/details/42673147 9. 内核的升级与卸载升级内核https://www.linuxidc.com/Linux/2018-06/152714.htm卸载内核https://blog.csdn.net/wf19930209/article/details/81879777 10. 安装/卸载mysqlmysql5.7安装https://segmentfault.com/a/1190000012703513 (目录名称都不要自定义)其中： /etc/my.cnf 中 pid-file=自定义一个有权限的目录 ，/var/run下重启后mysqld目录会消失，导致无法启动卸载https://www.cnblogs.com/jpfss/p/7932019.html问题：没有chkconfig命令https://blog.csdn.net/elim051/article/details/6173367You must reset your password using ALTER USER statement before executing this statement.https://www.cnblogs.com/debmzhang/p/5013540.html mysql8.0.16https://www.cnblogs.com/luoli-/p/9249769.html 11. 安装navicat在安装好deepin-wine的环境下：安装navicat11.2下载：http://packages.deepin.com/deepin/pool/non-free/n/navicat/navicat_11.2.9_amd64.deb进入安装目录 cd /usr/share/navicat/ 删除全部内容 sudo rm -r Navicat 将Windows中破解好的Navicat拷贝到 /usr/share/navicat/ 目录下 sudo cp -r Navicat /usr/share/navicat/ 注意：由于deepin的navicat是11.2.9的，所以windows下的破解版也要是11.2版本的才可以传送门：https://pan.baidu.com/s/1hsfBv2VtAd0jsekJwQGJuA 提取码：71nu 安装navicat12.1.18https://www.52pojie.cn/thread-966298-1-1.htmlhttps://github.com/DoubleLabyrinth/navicat-keygen/blob/windows/README_FOR_LINUX.zh-CN.md#navicat-keygen---for-linux 解决navicat中文乱码https://blog.csdn.net/qq_38250124/article/details/83898364https://blog.csdn.net/yuxiao97/article/details/84886921 12. 安装postmanhttp://packages.deepin.com/deepin/pool/non-free/p/postman/postman_6.0.9_amd64.deb 13. 安装ieaseMusichttps://github.com/trazyn/ieaseMusic/releases/download/v1.2.6/ieaseMusic-1.2.6-linux-amd64.deb 13. 安装qq，失败，参考置顶https://blog.csdn.net/qq_36428171/article/details/81209475 13. 安装微信，参考置顶网页版微信,加了个壳，没有电脑版好用 https://www.cnblogs.com/dunitian/p/9124806.html 14. 区域语言设置http://blog.sina.com.cn/s/blog_49f914ab0100sbsp.html 15. 静态iphttps://jingyan.baidu.com/article/29697b91558683ab20de3c95.htmlhttps://blog.csdn.net/qq_42975842/article/details/81705244 16. ssh免密登录https://blog.csdn.net/changhenshui1990/article/details/72896548https://www.cnblogs.com/ivan0626/p/4144277.html系统重装后清除原来的ssh信息：ssh-keygen -f "~/.ssh/known_hosts" -R "目标ip" 17. 安装openvpn安装http://www.seekswan.com/support_course_info_178开机自启openvpnhttps://www.jianshu.com/p/9af5d5a046f9 18. 卸载Ubuntu中wine安装的程序https://www.cnblogs.com/jackchiang/p/4072621.html 19. 安装markdown编辑器(Typora)http://packages.deepin.com/deepin/pool/non-free/t/typora/typora_0.9.53-1_amd64.deb 20. WPS for Linux（ubuntu）字体配置(字体缺失解决办法)https://www.cnblogs.com/liangml/p/5969404.html其他错误：INCORRECT PERMISSIONS ON /USR/LIB/PO1KIT-AGENT-HELPER-1(NEEDS TO BE SETUID ROOT)https://www.cnblogs.com/tl542475736/p/9461669.html 21. 在linux中使用vi 打开文件时，能显示行号https://blog.csdn.net/yuanyuan_186/article/details/51306202 22. 安装Virtualboxhttps://www.cnblogs.com/pealicx/p/9028414.htmlhttps://blog.csdn.net/weixin_43331296/article/details/83025126 23. 设置样式(桌面、顶栏、字体)https://www.jianshu.com/p/de37682ecbda]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】深入理解Java中的String]]></title>
    <url>%2F2019%2F03%2F11%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[个人所见最齐全最透彻的关于JAVA String的总结。 个人所见最齐全最透彻的关于JAVA String的总结。原文：https://www.cnblogs.com/xiaoxi/p/6036701.html 深入理解Java中的String一、String类想要了解一个类，最好的办法就是看这个类的实现源代码，来看一下String类的源码： 1234567891011121314151617181920public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ........&#125; 从上面可以看出几点： 1）String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。 2）上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。 下面再继续看String类的一些方法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125;public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = count; int i = -1; char[] val = value; /* avoid getfield opcode */ int off = offset; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[off + i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0 ; j &lt; i ; j++) &#123; buf[j] = val[off+j]; &#125; while (i &lt; len) &#123; char c = val[off + i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(0, len, buf); &#125; &#125; return this;&#125; 从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 二、字符串常量池​ 我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。所谓静态常量池，即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。而*运行时常量池**，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 来看下面的程序： 12String a = &quot;chenssy&quot;;String b = &quot;chenssy&quot;; a、b和字面上的chenssy都是指向JVM字符串常量池中的”chenssy”对象，他们指向同一个对象。 1String c = new String(&quot;chenssy&quot;); new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c—&gt;chenssy—&gt;池chenssy。整个关系如下： 通过上面的图我们可以非常清晰的认识他们之间的关系。所以我们修改内存中的值，他变化的是所有。 总结：虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 下面再来看几个例子： 例子1： 123456789/** * 采用字面值的方式赋值 */public void test1()&#123; String str1="aaa"; String str2="aaa"; System.out.println("===========test1============"); System.out.println(str1==str2);//true 可以看出str1跟str2是指向同一个对象 &#125; 执行上述代码，结果为：true。分析：当执行String str1=”aaa”时，JVM首先会去字符串池中查找是否存在”aaa”这个对象，如果不存在，则在字符串池中创建”aaa”这个对象，然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str1和str2指向了同一个对象，因此语句System.out.println(str1 == str2)输出：true。 例子2： 123456789/** * 采用new关键字新建一个字符串对象 */public void test2()&#123; String str3=new String("aaa"); String str4=new String("aaa"); System.out.println("===========test2============"); System.out.println(str3==str4);//false 可以看出用new的方式是生成不同的对象 &#125; 执行上述代码，结果为：false。 分析： 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象，如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象；如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。当执行String str4=new String(“aaa”)时， 因为采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句System.out.println(str3 == str4)输出：false。 例子3： 1234567891011/** * 编译期确定 */public void test3()&#123; String s0="helloworld"; String s1="helloworld"; String s2="hello"+"world"; System.out.println("===========test3============"); System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 &#125; 执行上述代码，结果为：true、true。 分析：因为例子中的s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以s0==s1为true；而”hello”和”world”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出s0==s1==s2。 例子4： 123456789101112/** * 编译期无法确定 */public void test4()&#123; String s0="helloworld"; String s1=new String("helloworld"); String s2="hello" + new String("world"); System.out.println("===========test4============"); System.out.println( s0==s1 ); //false System.out.println( s0==s2 ); //false System.out.println( s1==s2 ); //false&#125; 执行上述代码，结果为：false、false、false。 分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。 s0还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用。 例子5： 12345678910/** * 继续-编译期无法确定 */public void test5()&#123; String str1="abc"; String str2="def"; String str3=str1+str2; System.out.println("===========test5============"); System.out.println(str3=="abcdef"); //false&#125; 执行上述代码，结果为：false。 分析：因为str3指向堆中的”abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false。JVM对String str=”abc”对象放在常量池中是在编译时做的，而String str3=str1+str2是在运行时刻才能知道的。new对象也是在运行时才做的。而这段代码总共创建了5个对象，字符串池中两个、堆中三个。+运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。 步骤：1)栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。2)栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。3)栈中开辟一块中间存放引用str3。4)str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。5)引用str3指向堆中(str1 + str2)所还原的新String对象。6)str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。 例子6： 123456789101112131415/** * 编译期优化 */public void test6()&#123; String s0 = "a1"; String s1 = "a" + 1; System.out.println("===========test6============"); System.out.println((s0 == s1)); //result = true String s2 = "atrue"; String s3= "a" + "true"; System.out.println((s2 == s3)); //result = true String s4 = "a3.4"; String s5 = "a" + 3.4; System.out.println((s4 == s5)); //result = true&#125; 执行上述代码，结果为：true、true、true。 分析：在程序编译期，JVM就将常量字符串的”+”连接优化为连接后的值，拿”a” + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。 例子7： 12345678910/** * 编译期无法确定 */public void test7()&#123; String s0 = "ab"; String s1 = "b"; String s2 = "a" + s1; System.out.println("===========test7============"); System.out.println((s0 == s2)); //result = false&#125; 执行上述代码，结果为：false。 分析：JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即”a” + s1无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给s2。所以上面程序的结果也就为false。 例子8： 123456789101112/** * 比较字符串常量的“+”和字符串引用的“+”的区别 */public void test8()&#123; String test="javalanguagespecification"; String str="java"; String str1="language"; String str2="specification"; System.out.println("===========test8============"); System.out.println(test == "java" + "language" + "specification"); System.out.println(test == str + str1 + str2);&#125; 执行上述代码，结果为：true、false。 分析：为什么出现上面的结果呢？这是因为，字符串字面量拼接操作是在Java编译器编译期间就执行了，也就是说编译器编译时，直接把”java”、”language”和”specification”这三个字面量进行”+”操作得到一个”javalanguagespecification” 常量，并且直接将这个常量放入字符串池中，这样做实际上是一种优化，将3个字面量合成一个，避免了创建多余的字符串对象。而字符串引用的”+”运算是在Java运行期间执行的，即str + str2 + str3在程序执行期间才会进行计算，它会在堆内存中重新创建一个拼接后的字符串对象。总结来说就是：字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中；而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 例子9： 12345678910/** * 编译期确定 */public void test9()&#123; String s0 = "ab"; final String s1 = "b"; String s2 = "a" + s1; System.out.println("===========test9============"); System.out.println((s0 == s2)); //result = true&#125; 执行上述代码，结果为：true。 分析：和例子7中唯一不同的是s1字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的”a” + s1和”a” + “b”效果是一样的。故上面程序的结果为true。 例子10： 123456789101112131415/** * 编译期无法确定 */public void test10()&#123; String s0 = "ab"; final String s1 = getS1(); String s2 = "a" + s1; System.out.println("===========test10============"); System.out.println((s0 == s2)); //result = false &#125;private static String getS1() &#123; return "b"; &#125; 执行上述代码，结果为：false。 分析：这里面虽然将s1用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此s0和s2指向的不是同一个对象，故上面程序的结果为false。 三、总结1.String类初始化后是不可变的(immutable) String使用private final char value[]来实现字符串的存储，也就是说String对象创建之后，就不能再修改此对象中存储的字符串内容，就是因为如此，才说String类型是不可变的(immutable)。程序员不能对已有的不可变对象进行修改。我们自己也可以创建不可变对象，只要在接口中不提供修改数据的方法就可以。然而，String类对象确实有编辑字符串的功能，比如replace()。这些编辑功能是通过创建一个新的对象来实现的，而不是对原有对象进行修改。比如: 1s = s.replace("World", "Universe"); 上面对s.replace()的调用将创建一个新的字符串”Hello Universe!”，并返回该对象的引用。通过赋值，引用s将指向该新的字符串。如果没有其他引用指向原有字符串”Hello World!”，原字符串对象将被垃圾回收。 2.引用变量与对象 A aa;这个语句声明一个类A的引用变量aa[我们常常称之为句柄]，而对象一般通过new创建。所以aa仅仅是一个引用变量，它不是对象。 3.创建字符串的方式 创建字符串的方式归纳起来有两类： （1）使用””引号创建字符串 （2）使用new关键字创建字符串 结合上面例子，总结如下: （1）单独使用””引号创建的字符串都是常量,编译期就已经确定存储到String Pool中； （2）使用new String(“”)创建的对象会存储到heap中,是运行期新创建的； new创建字符串时首先查看池中是否有相同值的字符串，如果有，则拷贝一份到堆中，然后返回堆中的地址；如果池中没有，则在堆中创建一份，然后返回堆中的地址（注意，此时不需要从堆中复制到池中，否则，将使得堆中的字符串永远是池中的子集，导致浪费池的空间）！ （3）使用只包含常量的字符串连接符如”aa” + “aa”创建的也是常量,编译期就能确定,已经确定存储到String Pool中； （4）使用包含变量的字符串连接符如”aa” + s1创建的对象是运行期才创建的,存储在heap中； 4.使用String不一定创建对象 在执行到双引号包含字符串的语句时，如String a = “123”，JVM会先到常量池里查找，如果有的话返回常量池里的这个实例的引用，否则的话创建一个新实例并置入常量池里。所以，当我们在使用诸如String str = “abc”；的格式定义对象时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。 5.使用new String，一定创建对象 在执行String a = new String(“123”)的时候，首先走常量池的路线取到一个实例的引用，然后在堆上创建一个新的String实例，走以下构造函数给value属性赋值，然后把实例引用赋值给a： 12345678910111213141516171819public String(String original) &#123; int size = original.count; char[] originalValue = original.value; char[] v; if (originalValue.length &gt; size) &#123; // The array representing the String is bigger than the new // String itself. Perhaps this constructor is being called // in order to trim the baggage, so make a copy of the array. int off = original.offset; v = Arrays.copyOfRange(originalValue, off, off+size); &#125; else &#123; // The array representing the String is the same // size as the String, so no point in making a copy. v = originalValue; &#125; this.offset = 0; this.count = size; this.value = v; &#125; 从中我们可以看到，虽然是新创建了一个String的实例，但是value是等于常量池中的实例的value，即是说没有new一个新的字符数组来存放”123”。 6.关于String.intern() intern方法使用：一个初始为空的字符串池，它由类String独自维护。当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。 它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。 String.intern();再补充介绍一点：存在于.class文件中的常量池，在运行期间被jvm装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，java查找常量池中是否有相同unicode的字符串常量，如果有，则返回其引用，如果没有，则在常量池中增加一个unicode等于str的字符串并返回它的引用。 12345678910111213141516/** * 关于String.intern() */public void test11()&#123; String s0 = "kvill"; String s1 = new String("kvill"); String s2 = new String("kvill"); System.out.println("===========test11============"); System.out.println( s0 == s1 ); //false System.out.println( "**********" ); s1.intern(); //虽然执行了s1.intern(),但它的返回值没有赋给s1 s2 = s2.intern(); //把常量池中"kvill"的引用赋给s2 System.out.println( s0 == s1); //flase System.out.println( s0 == s1.intern() ); //true//说明s1.intern()返回的是常量池中"kvill"的引用 System.out.println( s0 == s2 ); //true&#125; 运行结果：false、false、true、true。 7.关于equals和== （1）对于==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），则直接比较其存储的”值”是否相等；如果作用于引用类型的变量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）。 （2）equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。 （3）对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。 12345678910111213/** * 关于equals和== */public void test12()&#123; String s1="hello"; String s2="hello"; String s3=new String("hello"); System.out.println("===========test12============"); System.out.println( s1 == s2); //true,表示s1和s2指向同一对象，它们都指向常量池中的"hello"对象 //flase,表示s1和s3的地址不同，即它们分别指向的是不同的对象,s1指向常量池中的地址，s3指向堆中的地址 System.out.println( s1 == s3); System.out.println( s1.equals(s3)); //true,表示s1和s3所指向对象的内容相同&#125; 8.String相关的+： String中的 + 常用于字符串的连接。看下面一个简单的例子： 12345678910/** * String相关的+ */public void test13()&#123; String a = "aa"; String b = "bb"; String c = "xx" + "yy " + a + "zz" + "mm" + b; System.out.println("===========test13============"); System.out.println(c);&#125; 编译运行后，主要字节码部分如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public static main([Ljava/lang/String;)V L0 LINENUMBER 5 L0 LDC "aa" ASTORE 1 L1 LINENUMBER 6 L1 LDC "bb" ASTORE 2 L2 LINENUMBER 7 L2 NEW java/lang/StringBuilder DUP LDC "xxyy " INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; (Ljava/lang/String;)V ALOAD 1 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC "zz" INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC "mm" INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ALOAD 2 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; ASTORE 3 L3 LINENUMBER 8 L3 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 3 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L4 LINENUMBER 9 L4 RETURN L5 LOCALVARIABLE args [Ljava/lang/String; L0 L5 0 LOCALVARIABLE a Ljava/lang/String; L1 L5 1 LOCALVARIABLE b Ljava/lang/String; L2 L5 2 LOCALVARIABLE c Ljava/lang/String; L3 L5 3 MAXSTACK = 3 MAXLOCALS = 4&#125; 显然，通过字节码我们可以得出如下几点结论：(1).String中使用 + 字符串连接符进行字符串连接时，连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符串常量连接起来，形成新的字符串常量参与后续连接（通过反编译工具jd-gui也可以方便的直接看出）； (2).接下来的字符串连接是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创建StringBuilder对象，然后依次对右边进行append操作，最后将StringBuilder对象通过toString()方法转换成String对象（注意：中间的多个字符串常量不会自动拼接）。 也就是说String c = “xx” + “yy “ + a + “zz” + “mm” + b; 实质上的实现过程是： String c = new StringBuilder(“xxyy “).append(a).append(“zz”).append(“mm”).append(b).toString(); 由此得出结论：当使用+进行多个字符串连接时，实际上是产生了一个StringBuilder对象和一个String对象。 9.String的不可变性导致字符串变量使用+号的代价： 12345String s = "a" + "b" + "c"; String s1 = "a"; String s2 = "b"; String s3 = "c"; String s4 = s1 + s2 + s3; 分析：变量s的创建等价于 String s = “abc”; 由上面例子可知编译器进行了优化，这里只创建了一个对象。由上面的例子也可以知道s4不能在编译期进行优化，其对象创建相当于： 123StringBuilder temp = new StringBuilder(); temp.append(a).append(b).append(c); String s = temp.toString(); 由上面的分析结果，可就不难推断出String 采用连接运算符（+）效率低下原因分析，形如这样的代码： 12345678public class Test &#123; public static void main(String args[]) &#123; String s = null; for(int i = 0; i &lt; 100; i++) &#123; s += "a"; &#125; &#125;&#125; 每做一次 + 就产生个StringBuilder对象，然后append后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后 append 字符串，如此循环直至结束。 如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 N - 1 次创建和销毁对象的时间。所以对于在循环中要进行字符串连接的应用，一般都是用StringBuffer或StringBulider对象来进行append操作。 10.String、StringBuffer、StringBuilder的区别 （1）可变与不可变：String是不可变字符串对象，StringBuilder和StringBuffer是可变字符串对象（其内部的字符数组长度可变）。 （2）是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然线程安全。StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer 中的方法大都采用了synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是非线程安全的。 （3）String、StringBuilder、StringBuffer三者的执行效率：StringBuilder &gt; StringBuffer &gt; String 当然这个是相对的，不一定在所有情况下都是这样。比如String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高。因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 11.String中的final用法和理解 123456final StringBuffer a = new StringBuffer("111");final StringBuffer b = new StringBuffer("222");a=b;//此句编译不通过final StringBuffer a = new StringBuffer("111");a.append("222");//编译通过 可见，final只对引用的”值”(即内存地址)有效，它迫使引用只能指向初始指向的那个对象，改变它的指向会导致编译期错误。至于它所指向的对象的变化，final是不负责的。 12.关于String str = new String(“abc”)创建了多少个对象？ 这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。 首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容： 很显然，new只调用了一次，也就是说只创建了一个对象。而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了”abc”对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念，该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个”abc”对象，而在代码执行过程中确实只创建了一个String对象。因此，这个问题如果换成 String str = new String(“abc”)涉及到几个String对象？合理的解释是2个。个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。 13.字符串池的优缺点：字符串池的优点就是避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。 四、综合实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.spring.test;public class StringTest &#123; public static void main(String[] args) &#123; /** * 情景一：字符串池 * JAVA虚拟机(JVM)中存在着一个字符串池，其中保存着很多String对象; * 并且可以被共享使用，因此它提高了效率。 * 由于String类是final的，它的值一经创建就不可改变。 * 字符串池由String类维护，我们可以调用intern()方法来访问字符串池。 */ String s1 = "abc"; //↑ 在字符串池创建了一个对象 String s2 = "abc"; //↑ 字符串pool已经存在对象“abc”(共享),所以创建0个对象，累计创建一个对象 System.out.println("s1 == s2 : "+(s1==s2)); //↑ true 指向同一个对象， System.out.println("s1.equals(s2) : " + (s1.equals(s2))); //↑ true 值相等 //↑------------------------------------------------------over /** * 情景二：关于new String("") * */ String s3 = new String("abc"); //↑ 创建了两个对象，一个存放在字符串池中，一个存在与堆区中； //↑ 还有一个对象引用s3存放在栈中 String s4 = new String("abc"); //↑ 字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象 System.out.println("s3 == s4 : "+(s3==s4)); //↑false s3和s4栈区的地址不同，指向堆区的不同地址； System.out.println("s3.equals(s4) : "+(s3.equals(s4))); //↑true s3和s4的值相同 System.out.println("s1 == s3 : "+(s1==s3)); //↑false 存放的地区多不同，一个栈区，一个堆区 System.out.println("s1.equals(s3) : "+(s1.equals(s3))); //↑true 值相同 //↑------------------------------------------------------over /** * 情景三： * 由于常量的值在编译的时候就被确定(优化)了。 * 在这里，"ab"和"cd"都是常量，因此变量str3的值在编译时就可以确定。 * 这行代码编译后的效果等同于： String str3 = "abcd"; */ String str1 = "ab" + "cd"; //1个对象 String str11 = "abcd"; System.out.println("str1 = str11 : "+ (str1 == str11)); //↑------------------------------------------------------over /** * 情景四： * 局部变量str2,str3存储的是存储两个拘留字符串对象(intern字符串对象)的地址。 * * 第三行代码原理(str2+str3)： * 运行期JVM首先会在堆中创建一个StringBuilder类， * 同时用str2指向的拘留字符串对象完成初始化， * 然后调用append方法完成对str3所指向的拘留字符串的合并， * 接着调用StringBuilder的toString()方法在堆中创建一个String对象， * 最后将刚生成的String对象的堆地址存放在局部变量str3中。 * * 而str5存储的是字符串池中"abcd"所对应的拘留字符串对象的地址。 * str4与str5地址当然不一样了。 * * 内存中实际上有五个字符串对象： * 三个拘留字符串对象、一个String对象和一个StringBuilder对象。 */ String str2 = "ab"; //1个对象 String str3 = "cd"; //1个对象 String str4 = str2+str3; String str5 = "abcd"; System.out.println("str4 = str5 : " + (str4==str5)); // false //↑------------------------------------------------------over /** * 情景五： * JAVA编译器对string + 基本类型/常量 是当成常量表达式直接求值来优化的。 * 运行期的两个string相加，会产生新的对象的，存储在堆(heap)中 */ String str6 = "b"; String str7 = "a" + str6; String str67 = "ab"; System.out.println("str7 = str67 : "+ (str7 == str67)); //↑str6为变量，在运行期才会被解析。 final String str8 = "b"; String str9 = "a" + str8; String str89 = "ab"; System.out.println("str9 = str89 : "+ (str9 == str89)); //↑str8为常量变量，编译期会被优化 //↑------------------------------------------------------over &#125;&#125; 运行结果： 运行结果： s1 == s2 : trues1.equals(s2) : trues3 == s4 : falses3.equals(s4) : trues1 == s3 : falses1.equals(s3) : truestr1 = str11 : truestr4 = str5 : falsestr7 = str67 : falsestr9 = str89 : true]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目代码和jar包分开打包]]></title>
    <url>%2F2019%2F02%2F14%2FMaven%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%92%8Cjar%E5%8C%85%E5%88%86%E5%BC%80%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Java Maven工程代码和依赖包分开打包的配置.. 引言代码包和依赖包分开打包这样的好处是：如果只修改了逻辑代码，没有修改依赖，就只需要更新代码包即可。在pom.xml中下中做如下修改： 步骤1&lt;project&gt;节点中修改 1&lt;packaging&gt;war&lt;/packaging&gt;改成&lt;packaging&gt;jar&lt;/packaging&gt; 步骤2&lt;build&gt;下&lt;plugins&gt;节点中注释掉 1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 步骤3&lt;build&gt;下&lt;plugins&gt;节点中添加如下配置： 1234567891011121314151617181920212223242526272829303132333435363738&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-installed&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;$&#123;project.groupId&#125;&lt;/groupId&gt; &lt;artifactId&gt;$&#123;project.artifactId&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;type&gt;$&#123;project.packaging&#125;&lt;/type&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;outputDirectory&gt;target/lib&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;copy-lib&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;includeScope&gt;compile&lt;/includeScope&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 效果图 参考: https://www.cnblogs.com/lishan1/p/10317488.html]]></content>
      <categories>
        <category>开发辅助工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot jar包作为Wrapper服务启动-Linux]]></title>
    <url>%2F2019%2F02%2F14%2FSpringBoot-jar%E5%8C%85%E4%BD%9C%E4%B8%BAWrapper%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8-Linux%2F</url>
    <content type="text"><![CDATA[SpringBoot应用封装成Wrapper服务的教程-Linux 引言同步Windows版本教程参考：SpringBoot jar包作为Wrapper服务启动-Windows此教程为Linux上将springboot jar作为服务启动, 版本：SpringBoot-2.1.2RELEASE。该服务中web程序的context-path、port都会以springboot中配置的为准。 步骤 下载Java Service Wrapper。目前最新版本为：3.5.37。选择自己对应的操作系统和位数，一般是Linux+x86 cpu。 修改conf/wrapper.conf文件，最好先备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#encoding=UTF-8&lt;font color=red&gt;##不知道为啥，这句去掉就不能启动服务&lt;/font&gt;#include ../conf/wrapper-license.conf#Specify the language and locale which the Wrapper should use.#需要取消注释，否则会去找wrapperjni_zh.mo文件，但是../lang/中没有该文件&lt;font color=red&gt;wrapper.lang=en_US # en_US or ja_JPwrapper.lang.folder=../lang&lt;/font&gt;#Java Applicationset.JAVA_HOME=/usr/local/java/jdk1.8.0_191wrapper.java.command=%JAVA_HOME%/bin/java#Java Library Path (location of Wrapper.DLL or libwrapper.so)wrapper.java.library.path.1=../lib#Tell the Wrapper to log the full generated Java command line.#wrapper.java.command.loglevel=INFO#老版本写法#wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperStartStopApp&lt;font color=red&gt;wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperSimpleApp&lt;/font&gt;#Java Classpath (include wrapper.jar) Add class path elements as needed starting from 1#自己的jar包路径&lt;font color=red&gt;wrapper.java.classpath.1=../lib/boot.jarwrapper.java.classpath.2=../lib/wrapper.jar&lt;/font&gt;#Java Bits. On applicable platforms, tells the JVM to run in 32 or 64-bit mode.wrapper.java.additional.auto_bits=TRUE#Java Additional Parameterswrapper.java.additional.1=#Initial Java Heap Size (in MB)#wrapper.java.initmemory=3#Maximum Java Heap Size (in MB)#wrapper.java.maxmemory=64#Application parameters. Add parameters as needed starting from 1&lt;font color=red&gt;wrapper.app.parameter.1=org.springframework.boot.loader.JarLauncher&lt;/font&gt;#如果代码包与依赖jar包分开打包也可以直接写main所在的入口类#wrapper.app.parameter.1=com.ysl.springboot.SpringbootApplication#Enables Debug output from the Wrapper.#wrapper.debug=TRUE#Format of output for the console. (See docs for formats)#wrapper.console.format=PMwrapper.console.format=LPDTM#Log Level for console output. (See docs for log levels)wrapper.console.loglevel=INFO#Log file to use for wrapper output logging.#wrapper.logfile=../logs/wrapper.log#wrapper 日志wrapper.logfile=../logs/boot_YYYYMMDD.logwrapper.logfile.rollmode=DATE#Format of output for the log file. (See docs for formats)#wrapper.logfile.format=LPTMwrapper.logfile.format=LPDTM#Log Level for log file output. (See docs for log levels)wrapper.logfile.loglevel=INFO#Maximum size that the log file will be allowed to grow to before#the log is rolled. Size is specified in bytes. The default value#of 0, disables log rolling. May abbreviate with the &apos;k&apos; (kb) or#&apos;m&apos; (mb) suffix. For example: 10m = 10 megabytes.wrapper.logfile.maxsize=0#Maximum number of rolled log files which will be allowed before old#files are deleted. The default value of 0 implies no limit.wrapper.logfile.maxfiles=0#Log Level for sys/event log output. (See docs for log levels)wrapper.syslog.loglevel=NONE#Allow for the use of non-contiguous numbered propertieswrapper.ignore_sequence_gaps=TRUE#Do not start if the pid file already exists.wrapper.pidfile.strict=TRUE#Title to use when running as a console &lt;u&gt;app.name in bin/testwrapper&lt;/u&gt;&lt;font color=red&gt;wrapper.console.title=@app.long.name@&lt;/font&gt;#********************************************************************#Wrapper JVM Checks#********************************************************************#Detect DeadLocked Threads in the JVM. (Requires Standard Edition)wrapper.check.deadlock=TRUEwrapper.check.deadlock.interval=10wrapper.check.deadlock.action=RESTARTwrapper.check.deadlock.output=FULL#Out Of Memory detection.#(Ignore output from dumping the configuration to the console. This is only needed by the TestWrapper sample application.)wrapper.filter.trigger.999=wrapper.filter.trigger.*java.lang.OutOfMemoryErrorwrapper.filter.allow_wildcards.999=TRUEwrapper.filter.action.999=NONE#Ignore -verbose:class output to avoid false positives.wrapper.filter.trigger.1000=[Loaded java.lang.OutOfMemoryErrorwrapper.filter.action.1000=NONE#(Simple match)wrapper.filter.trigger.1001=java.lang.OutOfMemoryError#(Only match text in stack traces if -XX:+PrintClassHistogram is being used.)#wrapper.filter.trigger.1001=Exception in thread &quot;*&quot; java.lang.OutOfMemoryError#wrapper.filter.allow_wildcards.1001=TRUEwrapper.filter.action.1001=RESTARTwrapper.filter.message.1001=The JVM has run out of memory.#Specify custom mail contentwrapper.event.jvm_restart.email.body=The JVM was restarted.\n\nPlease check on its status.\n#Name of the service. &lt;font color=red&gt;wrapper.name=@app.name@&lt;/font&gt;#Display name of the service &lt;u&gt;app.long.name in bin/testwrapper&lt;/u&gt;&lt;font color=red&gt;wrapper.displayname=@app.long.name@&lt;/font&gt;#Description of the service&lt;font color=red&gt;wrapper.description=Test Wrapper boot-Application Description&lt;/font&gt;#Service dependencies. Add dependencies as needed starting from 1wrapper.ntservice.dependency.1=#Mode in which the service is installed. AUTO_START, DELAY_START or DEMAND_STARTwrapper.ntservice.starttype=AUTO_START#Allow the service to interact with the desktop (Windows NT/2000/XP only).wrapper.ntservice.interactive=FALSEwrapper.ping.timeout=120 修改bin/testwrapper 在bin目录下执行启动服务：./testwrapper start停止服务：./testwrapper stop重启服务：./testwrapper restart 说在最后的话服务不是免费的 参考https://blog.csdn.net/myvernal/article/details/79104026https://my.oschina.net/u/3866531/blog/1845669/https://blog.csdn.net/sq287197314/article/details/82996012]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Wrapper服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot jar 作为Wrapper服务启动-Windows]]></title>
    <url>%2F2019%2F02%2F14%2FSpringBoot-jar-%E4%BD%9C%E4%B8%BAWrapper%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8-Windows%2F</url>
    <content type="text"><![CDATA[SpringBoot应用封装成Wrapper服务的教程-Windows 引言同步Linux版本教程参考：SpringBoot jar包作为Wrapper服务启动-Linux此教程为Windows上将SpringBoot jar作为服务启动, 版本：SpringBoot-2.1.2RELEASE。该服务中web程序的context-path、port都会以SpringBoot中配置的为准。 步骤 下载Java Service Wrapper。目前最新版本为：3.5.37。选择自己对应的操作系统和位数，一般是Windows+x86 cpu。 修改conf/wrapper.conf文件，最好先备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#encoding=UTF-8##不知道为啥，这句去掉就不能启动服务#include ../conf/wrapper-license.conf#需要取消注释，否则会去找wrapperjni_zh.mo文件，但是../lang/中没有该文件&lt;font color=red&gt;wrapper.lang=en_US # en_US or ja_JPwrapper.lang.folder=../lang/&lt;/font&gt;#java相关路径set.JAVA_HOME=D:\jdks\jdk1.8_181wrapper.java.command=%JAVA_HOME%/bin/java#老版本写法#wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperStartStopApp&lt;font color=red&gt;wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperSimpleApp&lt;/font&gt;#自己的jar包路径&lt;font color=red&gt;wrapper.java.classpath.1=../lib/boot.jarwrapper.java.classpath.2=../lib/wrapper.jar&lt;/font&gt;#Java Library Path (location of Wrapper.DLL or libwrapper.so)wrapper.java.library.path.1=../lib#Java Bits. On applicable platforms, tells the JVM to run in 32 or 64-bit mode.wrapper.java.additional.auto_bits=TRUE#Java Additional Parameterswrapper.java.additional.1=#Initial Java Heap Size (in MB)#wrapper.java.initmemory=3#Maximum Java Heap Size (in MB)#wrapper.java.maxmemory=64#Application parameters. Add parameters as needed starting from 1#这里很重要，这是Spring boot启动的入口&lt;font color=red&gt;wrapper.app.parameter.1=org.springframework.boot.loader.JarLauncher&lt;/font&gt;#如果代码包与依赖jar包分开打包也可以直接写main所在的入口类#wrapper.app.parameter.1=com.ysl.springboot.SpringbootApplication#wrapper.console.format=PMwrapper.console.format=LPDTM#Log Level for console output. (See docs for log levels)wrapper.console.loglevel=INFO#Log file to use for wrapper output logging.#wrapper.logfile=../logs/wrapper.log#wrapper 日志wrapper.logfile=../logs/boot_YYYYMMDD.logwrapper.logfile.rollmode=DATE#Format of output for the log file. (See docs for formats)#wrapper.logfile.format=LPTMwrapper.logfile.format=LPDTM#Log Level for log file output. (See docs for log levels)wrapper.logfile.loglevel=INFO#Maximum size that the log file will be allowed to grow to before the log is rolled. Size is specified in bytes. #The default value of 0, disables log rolling. May abbreviate with the &apos;k&apos; (kb) or &apos;m&apos; (mb) suffix. For example: 10m = 10 megabytes.wrapper.logfile.maxsize=0#Maximum number of rolled log files which will be allowed before old files are deleted. The default value of 0 implies no limit.wrapper.logfile.maxfiles=0#Log Level for sys/event log output. (See docs for log levels)wrapper.syslog.loglevel=NONE#Allow for the use of non-contiguous numbered propertieswrapper.ignore_sequence_gaps=TRUE#Do not start if the pid file already exists.wrapper.pidfile.strict=TRUE#Title to use when running as a consolewrapper.console.title=Test boot-Application#Detect DeadLocked Threads in the JVM. (Requires Standard Edition)wrapper.check.deadlock=TRUEwrapper.check.deadlock.interval=10wrapper.check.deadlock.action=RESTARTwrapper.check.deadlock.output=FULL#Out Of Memory detection.#(Ignore output from dumping the configuration to the console. This is only needed by the TestWrapper sample application.)wrapper.filter.trigger.999=wrapper.filter.trigger.*java.lang.OutOfMemoryErrorwrapper.filter.allow_wildcards.999=TRUEwrapper.filter.action.999=NONE#Ignore -verbose:class output to avoid false positives.wrapper.filter.trigger.1000=[Loaded java.lang.OutOfMemoryErrorwrapper.filter.action.1000=NONE#(Simple match)wrapper.filter.trigger.1001=java.lang.OutOfMemoryError#(Only match text in stack traces if -XX:+PrintClassHistogram is being used.)#wrapper.filter.trigger.1001=Exception in thread &quot;*&quot; java.lang.OutOfMemoryError#wrapper.filter.allow_wildcards.1001=TRUEwrapper.filter.action.1001=RESTARTwrapper.filter.message.1001=The JVM has run out of memory.#Specify custom mail contentwrapper.event.jvm_restart.email.body=The JVM was restarted.\n\nPlease check on its status.\n#Name of the service#这里是你的服务的名字&lt;font color=red&gt;wrapper.name=wrapper-boot&lt;/font&gt;#Display name of the service#这里是你的服务显示的名称&lt;font color=red&gt;wrapper.displayname=boot-Application&lt;/font&gt;#Description of the service#这里是你的服务的描述&lt;font color=red&gt;wrapper.description=boot-Application Description&lt;/font&gt;#Service dependencies. Add dependencies as needed starting from 1wrapper.ntservice.dependency.1=#Mode in which the service is installed. AUTO_START, DELAY_START or DEMAND_STARTwrapper.ntservice.starttype=AUTO_START#Allow the service to interact with the desktop (Windows NT/2000/XP only).wrapper.ntservice.interactive=FALSEwrapper.ping.timeout=120 双击运行bin/InstallTestWrapper-NT.bat，然后ctrl+alt+del查看服务是否安装成功。找到自己的服务右键启动即可。 说在最后的话服务不是免费的 参考https://blog.csdn.net/myvernal/article/details/79104026https://my.oschina.net/u/3866531/blog/1845669/https://blog.csdn.net/sq287197314/article/details/82996012]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Wrapper服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot在GlassFish上启动 ContainerBase.addChild: start: org.apache.catalina.LifecycleException]]></title>
    <url>%2F2019%2F02%2F13%2FSpringBoot%E5%9C%A8GlassFish%E4%B8%8A%E5%90%AF%E5%8A%A8-ContainerBase-addChild-start-org-apache-catalina-LifecycleException%2F</url>
    <content type="text"><![CDATA[SpringBoot应用不能再GlassFish4.x上启动的解决方法 遇到的问题在glassfish4.1.2版本中始终无法启动，报错： 12345678Error occurred during deployment: Exception while loading the app :java.lang.IllegalStateException: ContainerBase.addChild: start: org.apache.catalina.LifecycleException: org.apache.catalina.LifecycleException: org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'httpPutFormContentFilter' defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.class]:Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.web.servlet.filter.OrderedHttpPutFormContentFilter]: Factory method 'httpPutFormContentFilter' threw exception; nested exception is java.lang.VerifyError: Cannot inherit from final class. Please see server.log for more details. 测试了SpringBoot-2.0.5.RELEASE、SpringBoot-2.1.2.RELEASE都有此问题。 解决方法 GlassFish升级到GlassFish5.0就没问题了 将SpringBoot应用封装成Wrapper服务，再启动。参考：SpringBoot jar包作为Wrapper服务启动-LinuxSpringBoot jar包作为Wrapper服务启动-Windows]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>GlassFish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中将一列以逗号分隔的值行转列]]></title>
    <url>%2F2019%2F01%2F26%2FMySQL%E4%B8%AD%E5%B0%86%E4%B8%80%E5%88%97%E4%BB%A5%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E7%9A%84%E5%80%BC%E8%A1%8C%E8%BD%AC%E5%88%97%2F</url>
    <content type="text"><![CDATA[MySQL行转列案例… 前言有时会遇到没有遵守第一范式设计模式的业务表。即一列中存储了多个属性值。如下表 pk value 1 ET,AT 2 AT,BT 3 AT,DT 4 DT,CT,AT 一般有这两种常见需求(测试数据见文末) 得到所有的不重复的值，如 value AT BT CT DT ET SQL如下 123456select distinct(substring_index(substring_index(a.col,',',b.help_topic_id+1),',',-1))from (select group_concat(distinct `value`) as col from `row_to_col`) as ajoin mysql.help_topic as bon b.help_topic_id &lt; (char_length(a.col) - char_length(replace(a.col,',',''))+1) 显示每个值及其对应主键，如 pk value 1 ET 1 AT 2 AT 2 BT 3 AT 3 DT 4 DT 4 CT 4 AT SQL如下 123456select a.pk,substring_index(substring_index(a.col,',',b.help_topic_id+1),',',-1)from (select `value` as col,pk from `row_to_col`) as ajoin mysql.help_topic as bon b.help_topic_id &lt; (char_length(a.col) - char_length(replace(a.col,',',''))+1) 实现思路 需求1 通过group_concat函数将value列的值拼接成一个逗号隔开的字符串，然后通过substring_index函数对字符串进行截取 通过substring_index函数特性，我们就需要知道字符串有多少个逗号，并且要告诉每个逗号的位置 逗号个数=char_length(字符串)-char_length(replace(字符串,',','')) 逗号位置=mysql.help_topic.id &lt; 逗号个数[+1] 最后通过distinct函数将截取后的单个值进行去重 注意 mysql.help_topic表的自增id是从0开始，所以在进行截取时要对id进行+1。见: substring_index(a.col,',',b.help_topic_id+1) value列最后一个字符不是逗号时：逗号个数+1是为了截取时不漏掉最后一个逗号后的值，即: char_length(a.col) - char_length(replace(a.col,',',''))+1value列最后一个字符是逗号时：逗号个数就不需要+1了，直接：char_length(a.col) - char_length(replace(a.col,',','')) 因为截取时id要+1，所以在连接时取的&lt; ，而不是 &lt;= 。见：b.help_topic_id &lt; (char_length(a.col) - char_length(replace(a.col,',',''))[+1]) mysql.help_topic(mysql version: 5.7.21-1)表的自增id，最大值为636。如果group_concat后的字符串中逗号个数大于该值，需要自己单独处理自增id的值 需求2：思路基本与需求1同，只是最后的查询不一样 涉及到的函数 length:返回字符串所占的字节数，是计算字段的长度。一个汉字或是中文符号是算三个字符,一个数字或字母或英文符号算一个字符。 char_length:返回字符串所占的字符数，不管汉字还是数字或者是字母或者符号(不分中英文)都算是一个字符。 replace(str,old_string,new_string): 将字符串中str中所有的old_string替换成new_string。 substring_index(被截取字段，关键字，关键字出现的次数)：截取字符串。如果关键字出现的次数是负数 ， 则是从后倒数，到字符串结束。 group_concat([DISTINCT] 要连接的字段(可多个,逗号隔开) [Order BY 排序字段 ASC/DESC] [Separator '分隔符'])：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。分隔符，默认逗号。 测试数据1234567891011DROP TABLE IF EXISTS `row_to_col`;CREATE TABLE `row_to_col` ( `pk` int(11) NOT NULL AUTO_INCREMENT, `value` varchar(255) DEFAULT NULL, PRIMARY KEY (`pk`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;INSERT INTO `row_to_col` VALUES ('1', 'ET,AT');INSERT INTO `row_to_col` VALUES ('2', 'AT,BT');INSERT INTO `row_to_col` VALUES ('3', 'AT,DT');INSERT INTO `row_to_col` VALUES ('4', 'DT,CT,AT'); 参考：https://blog.csdn.net/liuzhoulong/article/details/51729168https://blog.csdn.net/ldl22847/article/details/47609727]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】Phoenix 异步建立二级索引失败，Hbase表名需大写]]></title>
    <url>%2F2019%2F01%2F25%2FPhoenix-%E5%BC%82%E6%AD%A5%E5%BB%BA%E7%AB%8B%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%A4%B1%E8%B4%A5%EF%BC%8CHbase%E8%A1%A8%E5%90%8D%E9%9C%80%E5%A4%A7%E5%86%99%2F</url>
    <content type="text"><![CDATA[Phoenix异步建立二级索引，必须要求Hbase表名需大写 环境：phoenix-5.0.0-Hbase-2.0.0关于怎么建立二级索引的原理及方法，我就不复述了，有需要的可以看看下面这些博客，挺好的转至：https://www.cnblogs.com/haoxinyue/p/6724365.html https://www.cnblogs.com/mario-nb/p/6350266.html?utm_source=itdadao&amp;utm_medium=referral 在这里我想强调的是，当我们的hbase表数据非常大时，测试大概5000万以上的数据建二级索引就会遇到连接超时的问题。 当然我们也可以调整连接时间如下：在客户端配置文件hbase-site.xml中，把超时参数设置大一些，足够build索引数据的时间。 12345678910111213141516171819202122232425262728&lt;property&gt;​&lt;name&gt;phoenix.query.timeoutMs&lt;/name&gt;&lt;value&gt;1200000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;​&lt;name&gt;phoenix.query.keepAliveMs&lt;/name&gt;&lt;value&gt;1200000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;​&lt;name&gt;hbase.rpc.timeout&lt;/name&gt;&lt;value&gt;1200000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;​&lt;name&gt;hbase.regionserver.lease.period&lt;/name&gt;&lt;value&gt;1200000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;​&lt;name&gt;hbase.client.operation.timeout&lt;/name&gt;&lt;value&gt;1200000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;​&lt;name&gt;hbase.client.scanner.caching&lt;/name&gt;&lt;value&gt;1000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;​&lt;name&gt;hbase.client.scanner.timeout.period&lt;/name&gt;&lt;value&gt;1200000&lt;/value&gt;&lt;/property&gt; 这种方式显然看起来就不太友好所以，我们就想到了用异步索引的方式去建立照着网上的方式:兴高采烈的去开干了，在linux输入以下命令： 123$&#123;HBASE_HOME&#125;/bin/hbase org.apache.phoenix.mapreduce.index.IndexTool --schema MY_SCHEMA --data-table MY_TABLE --index-table ASYNC_IDX --output-path ASYNC_IDX_HFILES 结果直接就报错了：它竟然说我的索引不是数表的索引，我当时就蒙了，这是咋回事呢？马上跑到phoenix client去查看，分明就是它的索引啊 ，可以通过命令查看 1select TABLE_NAME,DATA_TABLE_NAME,INDEX_TYPE,INDEX_STATE,INDEX_DISABLE_TIMESTAMP from system.catalog where INDEX_TYPE is not null; 那又是咋回事啊，想想是不是建索引出问题了，遂不信邪的再一次实验，继续出错，错误如出一辙，正当我准备放弃的时候。突然发现这好像有些不对，我的表分明是小写的t33，咋它说我的索引表却不是T33的index呢，是不是这个IndexTool有某种方式，将所有的表都转化为大写的呢，还是它只认识大写的表 接下来我就创建了一个大写的表去建索引，果然这次并没报错误，至于具体是哪种原因，没找到方法去研究。 结论：平时总喜欢建小写的hbase表，因为大写的看着别扭，这不自己把自己坑了几天，过程用同步索引都因为超时等各种原因，导致失败多次，让我哭会。。。。 大家又遇到这个问题么？ 原文链接：https://www.cnblogs.com/henyu/p/9179653.html]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
        <tag>Phoenix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phoenix varchar 空串等于null的坑]]></title>
    <url>%2F2019%2F01%2F15%2FPhoenix-varchar-%E7%A9%BA%E4%B8%B2%E7%AD%89%E4%BA%8Enull%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[举例说明，Phoenix将空串(“”)处理成null的坑 场景描述 业务的部分数据来源于hive，部分数据来源于hbase。两边数据通过一些条件字段关联，可是始终有部分数据关联不上。 hive数据源的数据直接通过hive api进行读写，hbase数据源通过phoenix读写。而且写入hbase的数据最终来源于hive，没道理会关联不上。 之后查找了好久，终于发现问题所在。就在phoenix对空串(“”)的处理，或者说没做写入处理。 通过下面案例说明 测试(phoenix-5.0.0-hbase-2.0.0) 建表： 12345678create table "test"( rk varchar primary key, "cf1"."c1" varchar, "cf1"."c2" varchar, "cf1"."c3" unsigned_int, "cf1"."c4" unsigned_long, "cf1"."c5" unsigned_double); 测试数据 12upsert into "test" (rk,"cf1"."c1","cf1"."c3","cf1"."c4","cf1"."c5") values ('rk1','varchar',100,111,1.123);upsert into "test" (rk,"cf1"."c1") values ('rk2',''); 查询结果 总结 phoenix 没有对空串(“”)进行处理，所以结果仍为null。 phoenix 对varchar 类型的null显示为空白，对数值类型的null显示为null。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
        <tag>Phoenix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hbase 启动失败，Please check the config value of 'hbase.procedure.store.wal.use.hsync']]></title>
    <url>%2F2019%2F01%2F08%2FHbase-%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%EF%BC%8CPlease-check-the-config-value-of-hbase-procedure-store-wal-use-hsync%2F</url>
    <content type="text"><![CDATA[Hadoop+Zookeeper+Hbase环境搭建时遇到的坑… 环境：JDK1.8Hadoop 2.7.1Zookeeper 3.4.6Hbase 2.0.0Apache Phoenix-5.0.0-Hbase-2.0.0 从hadoop到hbase的环境搭建一切正常，可直接参照网上教程，这里不累述。 这里记录一下我在配置phoenix连接hbase的时候遇到的问题。直观的看是HMaster先能启动，过一会又自动挂掉。日志错误信息如下： 1234567891011ERROR [master/YSL-MASTER:16000] master.HMaster: Failed to become active masterjava.lang.IllegalStateException: The procedure WAL relies on the ability to hsync for proper operation during component failures, but the underlying filesystem does not support doing so. Please check the config value of 'hbase.procedure.store.wal.use.hsync' to set the desired level of robustness and ensure the config value of 'hbase.wal.dir' points to a FileSystem mount that can provide it. at org.apache.hadoop.hbase.procedure2.store.wal.WALProcedureStore.rollWriter(WALProcedureStore.java:1043) at org.apache.hadoop.hbase.procedure2.store.wal.WALProcedureStore.recoverLease(WALProcedureStore.java:382) at org.apache.hadoop.hbase.procedure2.ProcedureExecutor.start(ProcedureExecutor.java:530) at org.apache.hadoop.hbase.master.HMaster.startProcedureExecutor(HMaster.java:1222) at org.apache.hadoop.hbase.master.HMaster.startServiceThreads(HMaster.java:1141) at org.apache.hadoop.hbase.master.HMaster.finishActiveMasterInitialization(HMaster.java:849) at org.apache.hadoop.hbase.master.HMaster.startActiveMasterManager(HMaster.java:2019) at org.apache.hadoop.hbase.master.HMaster.run(HMaster.java:553) at java.lang.Thread.run(Thread.java:748) 官网说明：http://hbase.apache.org/book.html#trouble.master.startup.hsync。 看了之后还是不知道怎么解决。 自己尝试了很多方法，换hadoop版本、修改hbase配置，替换hbase/lib目录下hadoop相关jar包(先删除原jar包)，这里记录一下替换命令：find /usr/local/hadoop-2.7.1/share/hadoop -name "hadoop*jar" | xargs -i cp {} /usr/local/hbase-2.0.0/lib/ 。网上也有说换hbase版本(未尝试)。网上最多的方法就是： 123456789101112131415hbase/conf/hbase-site.xml增加配置 &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;description&gt; Controls whether HBase will check for stream capabilities (hflush/hsync). Disable this if you intend to run on LocalFileSystem, denoted by a rootdir with the 'file://' scheme, but be mindful of the NOTE below. WARNING: Setting this to false blinds you to potential data loss and inconsistent system state in the event of process and/or node failures. If HBase is complaining of an inability to use hsync or hflush it's most likely not a false positive. &lt;/description&gt;&lt;/property&gt;该配置的作用是：如果你打算在本地文件系统中跑hbase，请禁掉此项。而我这里是将hbase跑在hdfs文件系统上，所以不能配置此项。 我的解决方法：删除每个节点hbase/lib目录下的phoenix-××-client.jar包，重启hbase即可。具体原因我也还没搞清楚，以后再更新。附上：hadoop-hbase 版本对应关系 记录下hbase/conf/hbase-site.xml中添加的配置： 123456789101112131415161718192021222324252627282930&lt;property&gt; &lt;name&gt;phoenix.schema.isNamespaceMappingEnabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;description&gt;开启schema与namespace的对应关系&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;phoenix.schema.mapSystemTablesToNamespace&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;description&gt;开启schema与namespace的对应关系&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;phoenix.functions.allowUserDefinedFunctions&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;description&gt;允许用户自定义函数(UDF)&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.regionserver.wal.codec&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec&lt;/value&gt; &lt;description&gt;开启phoenix 二级索引&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.regionserver.executor.openregion.threads&lt;/name&gt; &lt;value&gt;100&lt;/value&gt; &lt;description&gt;打开用户表region的线程数量(默认3)&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;phoenix.default.column.encoded.bytes.attrib&lt;/name&gt; &lt;value&gt;0&lt;/value&gt; &lt;description&gt;不对hbase列进行编码存储&lt;/description&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下 创建tomcat启动关闭快捷方式]]></title>
    <url>%2F2018%2F12%2F24%2FLinux%E4%B8%8B-%E5%88%9B%E5%BB%BAtomcat%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Linux下创建Tomcat快捷方式 原文：https://blog.csdn.net/rankun1/article/details/52816942 安装参考：https://blog.csdn.net/sun8112133/article/details/79944531 在linux下搭建好tomcat之后，每次启动和关闭都要去tomcat的bin目录下执行./startup.sh和./shutdown.sh 这是很不方便的，下面介绍如何像执行ls mv cp等命令一样启动，关闭，重启tomcat 创建脚本脚本创建路径 /etc/init.d/tomcat首先执行: vi /etc/init.d/tomcat按 i 编辑，将下面内容根据你自己的情况（修改/opt/java/tomcat8为你的tomcat路径）修改后copy到编辑框中， esc 退出编辑，:wq 保存退出 12345678910111213141516171819202122232425262728# !/bin/bash # Description: start or stop the tomcat # Usage: tomcat [start|stop|restart] # export PATH=$PATH:$HOME/binexport BASH_ENV=$HOME/.bashrcexport USERNAME=&quot;root&quot;case &quot;$1&quot; instart)#startup the tomcat cd /opt/java/tomcat8/bin./startup.sh;;stop)# stop tomcat cd /opt/java/tomcat8/bin./shutdown.shecho &quot;Tomcat Stoped&quot;;;restart)$0 stop$0 start;;*)echo &quot;tomcat: usage: tomcat [start|stop|restart]&quot;exit 1esacexit 0 脚本添加执行权限,执行命令 chmod +x /etc/init.d/tomcat创建软连接,执行下面两条命令 12cd /usr/bin ln -s /etc/init.d/tomcat . 测试好了，用下面的命令愉快的去玩耍吧 123tomcat starttomcat stoptomcat restart]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】Linux /opt、/var挂载到单独分区]]></title>
    <url>%2F2018%2F12%2F23%2FLinux-opt%E3%80%81-var%E6%8C%82%E8%BD%BD%E5%88%B0%E5%8D%95%E7%8B%AC%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Linux 上新建分区，参考教程：Linux 分区操作/opt 目录按照Linux /usr目录挂载到新分区此教程成功挂载。但是/var目录却一直未挂载成功。 下面给出/var目录的挂载步骤(/dev/sdb1为被挂载的分区)：1.创建一个挂载点：mkdir /storage。2.挂载 /dev/sdb1 到 /storage 目录上：mount /dev/sdb1 /storage。3.复制/var目录下的内容到/storage目录中：cp -pdr /var /storage。4.清空 /var目录 中的内容： rm -rf /var/* （通过ls命令看一下是否清空）。5.卸载 /dev/sdb1 : umount /dev/sdb1 。6.将 /dev/sdb1 挂载到 /var 上： mount /dev/sdb1 /var 。 然后通过 ls /var/ 命令查看 /var 中的内容。不过，我们会发现，原来的/var里的内容，现在被保存在了 /var/var/ 这样的目录下，而且还多了一个 lost+found 目录：为了和原来的 /var 保持一致，我们调整一下目录结构，依次执行下面三个命令：mv /var/var/* /var/rm -rf /var/varrm -rf /var/lost+found 设置开机自动挂载磁盘。打开 vim /etc/fstab 配置文件，在其后加上下面一句：/dev/sdb1 /var ext4 defaults 0 0不过，我们应该通过 blkid /dev/sdb1 查看一下磁盘分区UUID，将上面一句修改为：UUID=2d0a900b-4083-4d97-86f4-c66a0cd8249c /var ext4 defaults 0 0然后执行 mount -a 使得配置生效，或者重启。 参考原文https://ywnz.com/linuxjc/2219.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>目录挂载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux /usr目录挂载到新分区]]></title>
    <url>%2F2018%2F12%2F22%2FLinux-usr%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD%E5%88%B0%E6%96%B0%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[一篇关于Linux下/usr目录挂载到指定分区的教程 一、备份 1sudo cp -r /usr /usrbak 二、为/usr新建一个分区：参考教程：Linux 分区操作确保新分区没有挂载到其他目录。分区需要格式化成ext4格式(会清空数据) 1sudo mkfs -t ext4 /dev/sdxx 三、将目标分区挂在到一个临时目录 1sudo mount /dev/sdxx /usrtmp 四、 将/usr的全部内容拷到/usrtmp目录 1sudo cp -r /usr/. /usrtmp 五、修改目录所有者及权限： 123sudo chown root:root /usrtmp/bin/sudosudo chmod 4755 /usrtmp/bin/sudosudo chmod +s /usr/lib/policykit-1/polkit-agent-helper-1 否则sudo命令不能使用 六、取消/usrtmp目录的挂载 1sudo umount /dev/sdxxx 七、挂载到/usr目录 1sudo mount /dev/sdxx /usr 八、设置开机自动挂载： 查看分区uuid：sudo blkid 执行以下命令：sudo vi /etc/fstab，添加： UUID=对应分区的uuid /usr ext4 defaults 0 1 九、重启或执行sudo mount -a 问题 ubuntu18.0.4 : 使用sudo命令 提示:sudo: /usr/bin/sudo必须属于用户 ID 0(的用户)并且设置 setuid 位參考: https://blog.csdn.net/u014696921/article/details/70057447 INCORRECT PERMISSIONS ON /USR/LIB/PO1KIT-AGENT-HELPER-1(NEEDS TO BE SETUID ROOT)參考: https://www.cnblogs.com/tl542475736/p/9461669.html deepin15.8 分区是挂载上了，应用菜单中fcitx应用图标不见了，没有这个工具就不能配置中文输入法了。 查看是否还有残留的fcitx相关安装包：sudo dpkg --get-selections | grep fcitx如果有，将列表中所有安装包删除，并清除相关依赖sudo apt autoremove 安装搜狗输入法: sudo apt-get install sogoupinyin也可以参考：https://blog.csdn.net/github_33809414/article/details/85055814 重启 文件管理器中右键open in new window as admin点击无效了，解决方法还未找到。有解决方法了以后再更新。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux目录挂载</tag>
        <tag>目录挂载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 新建分区]]></title>
    <url>%2F2018%2F12%2F22%2FLinux-%E6%96%B0%E5%BB%BA%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Linux下硬盘新建分区教程 对Linux分区的理解 硬盘接口：1.IDE接口：Linux对连接到IDE接口的硬盘使用/dev/hdx的方式命名，x一般为a,b,c等2.SCSI接口：Linux对连接到SCSI接口的硬盘使用/dev/sdx的方式命名，x一般为a,b,c等。其实Linux对连接到SCSI接口的硬盘是使用ID号区分的。ID范围是：0-15，ID为0的硬盘名为/dev/sda，类推。SCSI主控制器通常占用ID号7，所以SCSI接口最多可连接15个硬盘。 分区：1.分区是针对磁盘，并不是对某一个分区分区。2.硬盘使用前要进行分区，可分为主分区，扩展分区，逻辑分区。硬盘使用前要进行分区，可分为主分区，扩展分区，逻辑分区。3.一块硬盘最多4个主分区，最多1个扩展分区，逻辑分区可以有若干个。4.扩展分区会使用一个主分区的位置。理解为：主分区数+扩展分区数不能超过4个。5.主分区中不能再划分其他类型的分区，相当于一个逻辑磁盘。6.扩展分区本身不存储任何东西，不能直接使用，也不能格式化，只是用于区分逻辑分区。所以，扩展分区容量=n个逻辑分区容量之和，从而：硬盘的容量=主分区容量+扩展分区容量。7.其中1-4为主分区+扩展分区编号，逻辑分区编号从5开始。 查看当前磁盘及分区情况可以看到我这里有两个磁盘，sda、sdb。其中sda有5个分区(sda4为扩展分区，sda5为逻辑分区)、sdb只有1个分区。 对硬盘进行分区操作123456789101112131415161718192021222324252627282930fdisk /dev/sda //操作sda磁盘...Command (m for help): m //输出帮助信息 Command action a toggle a bootable flag //设置启动分区 b edit bsd disklabel //编辑分区标签 c toggle the dos compatibility flag //切换DOS兼容性标志 d delete a partition //删除一个分区 l list known partition types //列出分区类型 m print this menu //输出帮助信息 n add a new partition //建立一个新的分区 o create a new empty DOS partition table //创建一个新的空白DOS分区表 p print the partition table //打印分区表 q quit without saving changes //退出不保存设置 s create a new empty Sun disklabel 创建一个新的空太阳标签 t change a partition&apos;s system id //改变分区的ID u change display/entry units //改变显示的单位 v verify the partition table //检查验证分区表 w write table to disk and exit //保存分区表 x extra functionality (experts only) Command (m for help):n Command action e extended //扩展分区 p primary partition (1-4) //主分区（最多4个）pPartition number (1-4): 1 //分区号(卷标)First cylinder (1-2597, default 1): 1 // 起始扇区Last cylinder or +size or +sizeM or +sizeK (1-2597, default 2597):+100M // 结束扇区 或大小Command (m for help): w //保存刚才的配置信息。 案例 删除sda4、sda5以新建分区 新建扩展分区我这里应该是有碎片区域，导致默认的扇区起始位置没有紧接sda3扇区之后。一般扩展分区就需要包含剩下的全部空间，否则就浪费了。 在扩展分区中新建逻辑分区 继续分区，个数无限制，任意分配，我这里分配2个 其他：将分区格式化为NTFS格式：sudo mkfs -t ntfs /dev/sda6 参考：https://www.cnblogs.com/sangmu/p/6629594.htmlhttps://www.cnblogs.com/hanson1/p/7102206.htmlhttps://www.cnblogs.com/lbole/archive/2018/04/25/8904298.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux分区</tag>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锐捷Linux客户端连接校园网]]></title>
    <url>%2F2018%2F12%2F17%2F%E9%94%90%E6%8D%B7Linux%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%2F</url>
    <content type="text"><![CDATA[Linux下锐捷客户端拨号上网教程 实验环境：成都信息工程大学(航空港校区)Deepin 15.8RG_Supplicant_For_Linux_V1.31.zip 一、下载并解压。 二、进入解压后的目录(rjsupplicant.sh所在目录)，打开终端(Terminal)，执行 1sudo ./rjsupplicant.sh --help 翻译如下： 认证客户端 - 使用帮助 -a --auth 认证方式(带参数，0表示无线认证，1表示有线认证；不指定时 采用上一次认证方式或者为有线认证) -d --dhcp dhcp方式(带参数，0表示静态IP认证，1表示使用动态获取IP方 式认证；不使用-d默认使用上一次配置) -n --nic 认证网卡(参数为网卡名称(参考-l结果)，不指定时采用上一次 使用的网卡或者第一张网卡) -s --service 服务(参数为服务名称(参考-l结果)，不指定时采用上一次使用 的服务或者第一个服务) -I --ssid 无线认证ssid(参数为ssid名称(参考-l结果)，不指定时采用上 一次使用的SSID或者第一个SSID，无线认证有效) -w --wlan 扫描无线网络: 无参数，可使用-n指定无线网卡，查看无线网络 列表 -u --user 用户名(参数为用户名，不指定时采用上一次使用的用户名) -p --password 密码(参数为密码，若未设定密码，运行程序后可重设定，默认 为空除非已经保存了密码) -S --save 保存密码(带参数，0表示不保存密码，1表示保存密码，不指定 时采用上一次配置) -q --quit 退出程序(不带参数，使用-q命令退出后台运行的客户端) -l --list 查看模式：无参数，指定该模式时，只查看信息，不认证。内容 包括：版本号，当前认证方式，当前网卡，当前服务(可选)，用 户名，服务列表(可选)，网卡列表。默认查看当前认证方式下信 息。 --comments 后台运行方式，输出日志在"/home/steven/下载/rjsupplicant/ x64/log/run.log"中 三、解绑原MAC地址(如果没有请忽略)进入校园网自助服务平台：http://10.254.241.18:8080/selfservice/ 我这里已经解绑过了。如果没有这一步，在连接时可能报错，如提示用户欠费等。 四、连接网络 根据自己情况设置连接参数。 -u 后跟的时用户名，一般是学号 -p 后跟的时密码 提示，Terminal窗口关闭，网络也会断开！！]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
      <tags>
        <tag>校园网</tag>
        <tag>锐捷客户端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis第一次启动，SHUTDOWN时提示： (error) ERR Errors trying to SHUTDOWN. Check logs.]]></title>
    <url>%2F2018%2F09%2F13%2FRedis%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%EF%BC%8CSHUTDOWN%E6%97%B6%E6%8F%90%E7%A4%BA%EF%BC%9A-error-ERR-Errors-trying-to-SHUTDOWN-Check-logs%2F</url>
    <content type="text"><![CDATA[今天我也是第一次玩redis，从下载到安装到HelloWorld一切顺风顺水，谁知在最后关闭redis时，出现了(error) ERR Errors trying to SHUTDOWN. Check logs.错误。下面贴出我的解决过程（可能有点繁琐） 今天我也是第一次玩redis，从下载到安装到HelloWorld一切顺风顺水，谁知在最后关闭redis时，出现了(error) ERR Errors trying to SHUTDOWN. Check logs.错误。下面贴出我的解决过程（可能有点繁琐） 环境Ubuntu 18.04 LTSredis-4.0.11 错误重现 解决过程很明显不保存就能关闭，多半跟日志文件有关系，就直接查看配置文件中关于日志的配置，如下：进行如下修改：再次启动，居然报错：于是查看日志文件权限，发现只有root用户有写权限：修改日志文件权限：再次启动：再次关闭，问题依然，感觉一朝回到解放前：继续找问题, 大致跟刚才同样的思路，找那种没有写权限的地方，发现如下：于是，查看一下/usr/local/myredis文件夹权限，与之前日志文件权限一样：索性直接把目录改成自己定义的：修改/usr/local/myredis/db_files/目录权限：查看结果：希望能对你有所帮助！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库字段级权限设计]]></title>
    <url>%2F2018%2F08%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E7%BA%A7%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[单纯个人设计的，关于数据库字段权限控制的解决方案，并附代码实现。应该有很多不足，有不好的地方可以指出，或者有更好的想法可以评论，一起交流^-^ 一、 引言 业务场景 在一个类似数据统计的系统中，由于统计的数据较多，就有较多的表，每个表有较多的字段，但是又不想让每个用户都看到全部的表或者表的全部字段，比如一些重要的统计数据，应该是只有管理员才能看到的。 举个例子(无实际意义) ID name day_amount week_amount month_amount 1 脑点子 1,000 7,000 30,000 A用户只能看到name，day_amount 两个字段；B用户只能看到name，month_amount两个字段。 二、 解决方案 方案一 用户表、用户-表名-字段映射表优点：实现简单缺点：每个用户，每个表，每个字段都需单独设置，较为繁琐 方案二 用户表、角色表、用户-角色映射表、角色-表名-字段映射表(优先级低)、用户-表名-字段映射表(优先级高)优点：可通过角色实现批量设置权限；且也可对某个用户权限进行单独设置缺点：权限局限于数据库单个表。 方案三 用户表、角色表、用户-角色映射表、数据类型表、类型-表名-字段映射表(优先级低)、角色-类型映射表、用户-表名-字段映射表(优先级高)优点：在方案二的基础上，可实现跨表的权限控制。缺点：实现较为繁琐，要不要采用主要还是根据用户的需求 对外权限分配接口 三种都按照表名作为一级节点，字段作为二级节点来分配权限。 方案一只能按照单个用户来分配权限 方案二按照角色/单个用户来分配 方案三按照类型/单个用户来分配 存在的问题 1）数据库结构变更时，与该表相关的所有权限都需要重新设置 2）部分不在数据库的字段，如根据多列的值计算出来的属性字段的权限不好处理。 3）只支持单张表的查询，不支持多表查询 部分解决思路 问题2）的暂时的解决思路是：再单独建一张表——用户/角色/类型-JAVA类名-属性名映射表，再配合JSON序列化的属性过滤来实现权限控制。这种方式基本跟完全写死没什么区别，对后期的维护及扩展极不友好！ 问题3）的解决思路是：放弃掉SQL语句的连接查询，全部改成由代码控制 三、 代码最初是打算在Spring Aop的前置通知中通过修改目标方法参数来实现，但是通过源码发现封装目标方法参数的类是用final修饰的，所以后面换了种思路。 使用Spring的AbstractAutoProxyCreator自动代理实现，思路是通过条件判断决定是否要使用自动代理，要使用代理的话，就需要自己实现MethodInterceptor接口并重写其中invoke方法。 下面我贴出核心代码，文章最后会给出整个demo的链接 继承AbstractAutoProxyCreator类，重写getAdvicesAndAdvisorsForBean()方法 1234567891011121314151617181920212223242526public class BeanTypeAutoProxyCreator extends AbstractAutoProxyCreator &#123; @Override protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource customTargetSource) throws BeansException &#123; return isMatch(beanClass) ? PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS : DO_NOT_PROXY; &#125; /** * 判断是否是需要被代理的对象 * @param clazz 代理对象的类型 * @return */ private boolean isMatch(Class&lt;?&gt; clazz) &#123; //有两个Class类型的类象，一个是调用isAssignableFrom方法的类对象（后称对象a）， // 以及方法中作为参数的这个类对象(称之为对象b)，这两个对象如果满足以下条件则返回true，否则返回false： //a对象所对应类信息是b对象所对应的类信息的父类或者是父接口，简单理解即a是b的父类或接口 //a对象所对应类信息与b对象所对应的类信息相同，简单理解即a和b为同一个类或同一个接口 if (BaseMapper.class.isAssignableFrom(clazz)) &#123; return true; &#125; return false; &#125;&#125; 实现MethodInterceptor接口，重写invoke()方法 123456789101112131415161718192021222324252627282930313233public class MyMethodInterceptor implements MethodInterceptor &#123; @Autowired private SysAccess sysAccess; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; // 权限封装类 SysAccessCriteria result = null; int flag = -1; // 目标方法的参数 Object[] args = invocation.getArguments(); for (int i=0; i&lt;args.length; i++) &#123; // 只修改权限条件类型的参数 if(args[i] instanceof SysAccessCriteria)&#123; SysAccessCriteria sysAccessCriteria = (SysAccessCriteria) args[i]; result = sysAccess.getUserAceess(sysAccessCriteria); flag = i; &#125; &#125; // 修改目标参数 if(flag &gt;= 0 &amp;&amp; result != null)&#123; args[flag] = result; &#125; // 执行目标方法 Object object = invocation.proceed(); return object; &#125;&#125; 配置到Spring配置文件中 12345678910&lt;bean id="myMethodInterceptor" class="com.ysl.access.proxy.MyMethodInterceptor"&gt;&lt;/bean&gt;&lt;!--配置自动代理--&gt;&lt;bean id="myBeanTypeAutoProxyCreator" class="com.ysl.access.proxy.BeanTypeAutoProxyCreator"&gt; &lt;!--父类属性--&gt; &lt;property name="interceptorNames"&gt; &lt;list&gt; &lt;value&gt;myMethodInterceptor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; Demo完整代码(数据库文件在resources目录下)：https://github.com/andus-top/columns-accsss单纯个人设计，应该有很多不足，有不好的地方可以指出，或者有更好的想法可以评论，一起交流。 参考：https://blog.csdn.net/lilongjiu/article/details/78047051]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>权限设计</tag>
        <tag>Mysql</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-axios 前后端分离 跨域访问的实现]]></title>
    <url>%2F2018%2F08%2F22%2Fvue-axios-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一篇关于vue-axios与ssm工程跨域配置的记录… 一. 基本环境 前端vue：2.5.6axios：0.18使用vue脚手架构建项目。参照：webstorm搭建vue项目 后台ssm框架 前后端数据采用json格式传输 二. 前端配置 axios配置 安装 1npm install axios --save 在所需组件中引入axios 1import axios from 'axios'; 在&lt;script&gt;中配置axios参数 123456const myaxios = axios// 不跨域的axios// 如果要跨域的话, 对axios进行一些设置,当前使用的是跨域的const axiosInstance = axios.create(&#123; headers: &#123;'Content-Type': 'application/json;charset=utf-8'&#125;,// 设置传输内容的类型和编码 withCredentials: true,// 指定某个请求应该发送凭据。允许客户端携带跨域cookie，也需要此配置&#125;); 代理配置打开config/index.js文件，找到dev对象里面的proxyTable修改为如下内容： 12345678910proxyTable: &#123; '/api': &#123; target:'http://127.0.0.1:80', // secure: false, // 如果是https接口，需要配置这个参数 changeOrigin:true, pathRewrite:&#123; '^/api': '' &#125; &#125;&#125;, target 的参数就是你要访问的服务器地址, 你在代码里面写/api就等于写了这个地址 , 比如我要访问http://127.0.0.1:80/vue-ssm/login这个接口在代码里面只需写/api/vue-ssm/login就可以了 使用axios发送请求 123456789// 跨域访问axiosInstance.post('/api/vue-ssm/login', 请求的参数,).then( response =&gt; &#123; console.log(response.data);// response.data为后端返回的具体数据 alert("请求成功");&#125;).catch( error =&gt; &#123; alert("请求失败");&#125;); axios详细参数配置可以参考：Axios 中文说明 三. 后端配置 使用SpringMvc的HandlerInterceptorAdapter拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class RquestInterceptor extends HandlerInterceptorAdapter &#123; /** * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败）， * 不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应； */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 允许客户端携带跨域cookie // 当Access-Control-Allow-Credentials设为true的时候，Access-Control-Allow-Origin不能设为星号 response.setHeader("Access-Control-Allow-Credentials", "true"); // 允许指定域访问跨域资源 //response.setHeader("Access-Control-Allow-Origin", "http://127.0.0.1:9006, http://127.0.0.1:8080"); response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));// * // 允许浏览器发送的请求消息头 response.setHeader("Access-Control-Allow-Headers", request.getHeader("Access-Control-Request-Headers"));// * // 允许浏览器在预检请求成功之后发送的实际请求方法名 response.setHeader("Access-Control-Allow-Methods", request.getHeader("Access-Control-Request-Method")); // 设置响应数据格式 response.setHeader("Content-Type", "application/json"); // 查看请求方法 String method= request.getMethod(); System.out.println(method); return true; &#125; /*下面的方法可以不重写*/ /** * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象） * 对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; super.postHandle(request, response, handler, modelAndView); &#125; /** * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间， * 还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; super.afterCompletion(request, response, handler, ex); &#125; /** * 处理异步请求 * 不是HandlerInterceptor的接口实现，是AsyncHandlerInterceptor的 * AsyncHandlerInterceptor实现了HandlerInterceptor */ public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; super.afterConcurrentHandlingStarted(request, response, handler); &#125;&#125; 配置到SpringMvc配置文件 123456789&lt;mvc:interceptors&gt; &lt;!-- 注意拦截器的执行顺序，会按照这里配置顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!--匹配所有路径--&gt; &lt;bean class="com.ysl.interceptor.RquestInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;!-- 其他拦截器 --&gt; &lt;mvc:interceptor&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 好了，这就是我使用axios实现跨域访问的全过程，希望对大家有所帮助。 参考：https://blog.csdn.net/huang100qi/article/details/77132096https://blog.csdn.net/qq_22844483/article/details/78661030https://www.jianshu.com/p/1e8d088c2be9https://segmentfault.com/a/1190000015597029]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>axios</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
</search>
