<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="keywords" content="个人博客, 松林羊, ysl, songlinsheep, andus, blog, 个人站点, 个人网站"><meta name="description" content="松林羊的个人网站，用于记录，分享。欢迎交流^-^"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title> Java多线程(一)-基础篇 | 松林羊</title><link rel="shortcut icon" href="/smile.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><script src="/js/pace.min.js"></script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"1559132c"}),daovoice("update")</script></head></html><body><main class="content"><section class="outer"><article id="post-Java多线程-一-基础篇" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name"> Java多线程(一)-基础篇</h1></header><div class="article-meta"> <a href="/2019/11/08/Java多线程-一-基础篇/" class="article-date"><time datetime="2019-11-08T13:55:06.000Z" itemprop="datePublished">2019-11-08</time></a><div class="article-category"> <a class="article-category-link" href="/categories/编程语言/">编程语言</a></div> &emsp;<i class="fe fe-bar-chart"></i> <span class="post-count">3.9k</span>字 &emsp;<i class="fe fe-clock"></i> <span class="post-count">15</span>分钟</div><div class="tocbot"></div><div class="article-entry" itemprop="articleBody"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><b>进程</b></p><ul><li>正在执行的程序，拥有独立的代码和数据空间</li><li>进程间的切换会有较大的开销</li><li>是资源分配的最小单位</li><li>一个进程可以包含一个或多个线程</li><li>至少包含一个线程</li></ul><p><b>线程</b></p><ul><li>程序中单独顺序的控制流</li><li>线程本身依靠进程进行运行，只能用分配给进程的资源和环境</li><li>同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)</li><li>是cpu调度的最小单位</li></ul><p><b>单线程</b></p><ul><li>进程中只存在一个线程，实际上主方法就是一个主线程</li></ul><p><b>多线程</b></p><ul><li>一个进程中运行多个线程</li><li>目的：更好的使用CPU资源</li></ul><p><b>并行</b></p><ul><li>真正的同时，多个cpu实例或者多台机器同时执行一段处理逻辑。</li></ul><p><b>并发</b></p><ul><li>通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。使用TPS或者QPS来反应这个系统的并发处理能力</li></ul><p><b>线程安全</b></p><ul><li>并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果</li></ul><p><b>同步</b></p><ul><li>保证共享资源的多线程访问成为线程安全</li></ul><p><b>死锁</b></p><ul><li>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁</li><li>结果就是这些线程都陷入了无限的等待中</li></ul><h1 id="常见线程名词"><a href="#常见线程名词" class="headerlink" title="常见线程名词"></a>常见线程名词</h1><p><b>主线程</b><br>JVM调用程序main()所产生的线程。</p><p><b>当前线程</b><br>无特别说明，一般指通过Thread.currentThread()来获取的进程。</p><p><b>后台线程</b></p><ol><li>为其他线程提供服务的线程，也称为守护线程。</li><li>例如，JVM的垃圾回收线程就是一个后台线程。</li><li>区别在于，守护线程等待主线程，依赖于主线程结束而结束。</li></ol><p><b>前台线程</b></p><ol><li>接受后台线程服务的线程。</li><li>前台后台线程关系就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。</li><li>由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</li></ol><h1 id="Java中线程基础知识"><a href="#Java中线程基础知识" class="headerlink" title="Java中线程基础知识"></a>Java中线程基础知识</h1><ol><li>main()方法也是一个线程，<code>Thread.currentThread().getName()</code> 得到的值为main，所有俗称main线程。</li><li>Java中，每次程序至少启动2个线程。一个main线程，一个是垃圾收集线程。</li><li>每当使用Java命令执行一个类的时候，实际上都会启动一个JVM，而每一个JVM就是在操作系统中启动了一个进程。（<font color="red">待验证</font>）</li><li>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。</li></ol><h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><h3 id="继承java-lang-Thread类"><a href="#继承java-lang-Thread类" class="headerlink" title="继承java.lang.Thread类"></a>继承java.lang.Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自定义线程名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread01</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(name+<span class="string">"："</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread01 t1 = <span class="keyword">new</span> MyThread01(<span class="string">"A"</span>);</span><br><span class="line">        MyThread01 t2 = <span class="keyword">new</span> MyThread01(<span class="string">"B"</span>);</span><br><span class="line">        <span class="comment">// 此时程序依然是顺序执行</span></span><br><span class="line">        <span class="comment">//t1.run();</span></span><br><span class="line">        <span class="comment">//t2.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println("----------------华丽分割线----------------");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过start()方法启动线程，此时t1、t2线程交替执行</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>说明</b></p><ol><li>程序启动运行main()时候，Java虚拟机启动一个进程，主线程在main()方法调用时候被创建。</li><li>随着调用t1、t2的start()方法，另外两个线程也启动了，这样，整个应用就在多线程下环境下运行了。</li><li>调用start()方法并不会立刻执行线程的代码，而是使该线程变为可运行状态(后面线程生命周期章节会有讲解)，什么时候执行是由操作系统决定的。</li><li>线程的启动是通过start()方法，且不能重复调用。直接通过对象调用run()方法程序依然是顺序执行。</li><li>多运行几次代码，你会发现，多线程的执行顺序是不固定的，每次执行哪个线程是随机的。</li><li>查看Thread类的源码，可以发现Thread类是Runable接口的一个实现类。</li></ol><h3 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunable02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"："</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunable02 r1 = <span class="keyword">new</span> MyRunable02();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过start()方法启动线程，此时t1、t2线程交替执行</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>说明</b></p><ol><li>通过实现Runable接口，使普通的Java类具有了多线程的特性。</li><li>run()方法是多线程程序的一个约定，所有多线程的代码都在run()方法里面。</li><li>仔细观察代码可以发现，最终线程的启动还是通过Thread类的start()方法。</li><li>实际上Java中所有多线程代码都是通过Thread.start()方法来启动的。因此，熟悉Thread类的API是Java并发编程的基础。</li></ol><h5 id="推荐使用Runable的方式"><a href="#推荐使用Runable的方式" class="headerlink" title="推荐使用Runable的方式"></a>推荐使用Runable的方式</h5><ol><li>避免Java单继承的限制。</li><li>降低数据与代码的耦合度，代码与数据独立，代码逻辑可被多个线程共享。</li><li>线程池不能直接放入Thread类对象，可以放入Runable、Callable对象。</li></ol><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ol><li>这里先简单普及一下，在Java中Runnable的run()方法没有返回值，而Callable接口里的call()方法可返回值。</li><li>Java常用Future接口来代表Callable接口里的call()方法的返回值，并为Future接口提供了一个FutureTask实现类。</li><li>FutureTask类同时实现了Future、Runnable接口。</li></ol><h5 id="并发执行同一个FutureTask"><a href="#并发执行同一个FutureTask" class="headerlink" title="并发执行同一个FutureTask"></a>并发执行同一个FutureTask</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable03</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": "</span>+sum);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 虽然是并发执行，但是最终只会执行其中一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Thread-0"</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = <span class="number">0</span>; <span class="comment">// 此处this就是c1</span></span><br><span class="line">            System.out.println(<span class="string">"now Thread: Thread-0"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"Thread-1"</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=<span class="number">10</span>; <span class="comment">// 此处this就是c1</span></span><br><span class="line">            System.out.println(<span class="string">"now Thread: Thread-1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">" result："</span>+sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCallable03 c1 = <span class="keyword">new</span> MyCallable03();</span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(c1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// t1、t2并发执行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(f1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(f1);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.isDone()); <span class="comment">// f1执行完毕才是true</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  <span class="comment">//  main线程sleep，保证t1、t2执行完毕</span></span><br><span class="line">        <span class="keyword">if</span>(f1.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">"结果： "</span>+f1.get());  <span class="comment">// 结果： Thread-1 result：45</span></span><br><span class="line">            System.out.println(t1.getState().toString());  <span class="comment">// TERMINATED</span></span><br><span class="line">            System.out.println(t2.getState().toString());  <span class="comment">// TERMINATED</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"num："</span>+c1.num);  <span class="comment">// 执行的t1为num：0，执行的t2为num：10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>说明</b></p><ol><li>由t1、t2的状态得出，两个线程都执行了。</li><li>根据num的值与输出的“now Thread: Thread-?”结果得出，一个FutureTask只会被执行一次。</li></ol><h5 id="先后执行同一个FutureTask"><a href="#先后执行同一个FutureTask" class="headerlink" title="先后执行同一个FutureTask"></a>先后执行同一个FutureTask</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable0302</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": "</span>+sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最终只会执行其中一个</span></span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>))&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = <span class="number">0</span>; <span class="comment">// 此处this就是c1</span></span><br><span class="line">            System.out.println(<span class="string">"now Thread: Thread-0"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"Thread-1"</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=<span class="number">10</span>; <span class="comment">// 此处this就是c1</span></span><br><span class="line">            System.out.println(<span class="string">"now Thread: Thread-1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">" result："</span>+sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCallable0302 c1 = <span class="keyword">new</span> MyCallable0302();</span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(c1);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(f1);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时会继续执行主线程的代码。</span></span><br><span class="line">        System.out.println(f1.isDone()); <span class="comment">// f1执行完毕才是true</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">//  main线程sleep，保证t1执行完毕</span></span><br><span class="line">        <span class="keyword">if</span>(f1.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">"第一次： "</span>+f1.get());  <span class="comment">// 第一次： Thread-0 result：45</span></span><br><span class="line">            System.out.println(<span class="string">"num："</span>+c1.num); <span class="comment">// num：0</span></span><br><span class="line">            System.out.println(t1.getState().toString());  <span class="comment">// TERMINATED</span></span><br><span class="line"></span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(f1);<span class="comment">// 此时，f1中的call方法都不会被执行，相当于没传f1</span></span><br><span class="line">            t2.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// main线程sleep，保证t2执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">"第二次： "</span>+f1.get());  <span class="comment">// 第二次： Thread-0 result：45（依然是t1执行f1的结果）</span></span><br><span class="line">            System.out.println(t2.getState().toString()); <span class="comment">// TERMINATED</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"num："</span>+c1.num); <span class="comment">// num：0 (依然是t1执行f1的结果)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程执行第一个线程已经执行完的f1，第二个线程会执行,但是不是执行f1中的call方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>说明</b></p><ol><li>由两个“依然是t1执行f1的结果”进一步验证了：一个FutureTask只会被执行一次。</li></ol><h1 id="线程中常用方法"><a href="#线程中常用方法" class="headerlink" title="线程中常用方法"></a>线程中常用方法</h1><table><thead><tr><th>方法名</th><th>作用</th><th>详解</th></tr></thead><tbody><tr><td>getName()</td><td>获取线程名称</td><td>Thread.currentThread().getName()</td></tr><tr><td>currentThread()</td><td>获取当前线程对象</td><td>currentThread()方法是Thread类的静态方法，如果调用线程对象.currentThread()方法并不能获取到调用的线程对象，反正在哪一个线程里面执行了currentThread()方法得到的就是哪个线程对象</td></tr><tr><td>isAlive()</td><td>线程是否存活</td><td>如果线程已经启动，并且没有died返回true</td></tr><tr><td>join()</td><td>等待该线程终止</td><td>在一个线程中调用other.join(),将等待other执行完后才继续本线程。(见补充说明)</td></tr><tr><td>sleep()</td><td>线程的休眠</td><td>见补充说明</td></tr><tr><td>yield()</td><td>线程礼让</td><td>当前线程可转让cpu控制权，让别的就绪状态线程运行(见补充说明)</td></tr><tr><td>interrupte()</td><td>友好的终止线程执行</td><td>保证程序逻辑完整性(见补充说明)</td></tr><tr><td>wait()</td><td>线程挂起，进入等待队列</td><td><a href="http://www.andus.top/2019/11/18/JAVA多线程-Object-wait-，Object-notify-，Object-notifyAll/">JAVA多线程-Object.wait()，Object.notify()，Object.notifyAll()</a></td></tr><tr><td>notify()</td><td>唤醒等待队列中任意一个线程</td><td><a href="http://www.andus.top/2019/11/18/JAVA多线程-Object-wait-，Object-notify-，Object-notifyAll/">JAVA多线程-Object.wait()，Object.notify()，Object.notifyAll()</a></td></tr><tr><td>notifyAll()</td><td>唤醒等待队列中所有线程</td><td><a href="http://www.andus.top/2019/11/18/JAVA多线程-Object-wait-，Object-notify-，Object-notifyAll/">JAVA多线程-Object.wait()，Object.notify()，Object.notifyAll()</a></td></tr><tr><td>suspend()</td><td>线程挂起</td><td>不会释放对象锁，不推荐使用，常与resume()配套使用</td></tr><tr><td>resume()</td><td>唤醒挂起线程</td><td>不推荐使用，常与suspend()配套使用。如果 resume() 操作出现在 suspend() 之前执行，很容易造成死锁</td></tr><tr><td>activeCount()</td><td>进程中活跃的线程数</td><td></td></tr><tr><td>enumerate()</td><td>枚举程序中的线程</td><td></td></tr><tr><td>isDaemon()</td><td>一个线程是否为守护线程</td><td></td></tr><tr><td>setDaemon()</td><td>设置一个线程为守护线程</td><td>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</td></tr><tr><td>setPriority()</td><td>设置一个线程的优先级</td><td>取值1-10</td></tr></tbody></table><p><b>补充说明</b></p><p><b>join()</b><br>这里是指的主线程等待子线程的终止。如果还要其他线程的话，调用join()方法的线程会与除主线程外的其他线程并发执行。所以，当主线程需要用到子线程的处理结果，这个时候就要用到join()方法。</p><p><b>yield()</b><br>让当前运行线程从<b>运行状态(Running)</b>回到<b>可运行状态(Runable)</b>，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让<b>相同优先级</b>的线程之间能适当的<b>轮转执行</b>。但是，实际中无法保证yield()达到让步目的，因为<b>让步的线程</b>还有可能被线程调度程序<b>再次选中</b>。</p><p><b>sleep()</b><br>线程休眠，<font color="pink">不会释放锁</font><br>sleep()方法是Thread类的静态方法，如果调用线程对象.sleep()方法并不是该线程就休眠，反正在哪一个线程里面执行了sleep()方法哪一个线程就休眠。<br>在sleep()休眠时间期满后，该线程不一定会立刻获得cpu资源，除非此线程具有更高的优先级。</p><p><font color="#fda504"><b>sleep()、yield()的区别</b></font><br>sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行。这段时间是通过程序设定的。<br>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程可能进入到可执行状态后又马上被执行，这段时间是不可设定的。<br>实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。<br>sleep() 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。所以，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，<font color="red">较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行</font>。</p><p><b>interrupte()</b><br>不要以为它是中断某个线程！它只是向线程发送一个中断信号。正常运行的程序不去检测状态就不会终止。<br>只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。</p><p><b>stop()</b><br>是一种”恶意” 的中断,一旦执行stop方法,即终止当前正在运行的线程,不管线程逻辑是否完整,这是非常危险的。</p><p><b>综合interrupte()、stop()，建议使用自定义的<u>标志位</u>决定线程的执行情况</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeStopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此变量必须加上volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断线程体是否运行</span></span><br><span class="line">        <span class="keyword">while</span> (stop) &#123;</span><br><span class="line">            <span class="comment">// Do Something</span></span><br><span class="line">            System.out.println(<span class="string">"Stop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程终止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul><li>Java线程的优先级用整数表示，取值范围是1~10，数值越大优先级越高。优先级高的线程获得更多运行机会的机会越大。</li><li>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</li><li>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</li><li>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.MIN_PRIORITY =&gt; <span class="number">1</span></span><br><span class="line">Thread.MAX_PRIORITY=&gt; <span class="number">10</span></span><br><span class="line">Thread.NORM_PRIORITY=&gt; <span class="number">5</span>(默认)</span><br></pre></td></tr></table></figure></li></ul><p><b>说明</b></p><ol><li>线程的优先级<b>有可能</b>影响线程的执行顺序，不是绝对的。</li></ol><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>有共享数据时就需要同步！！！</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在代码块上加上”synchronized” 关键字，则此代码块就成为同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象)&#123;</span><br><span class="line">          需要同步的代码块;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法返回修饰符之前加上”synchronized” 关键字，则此方法就成为同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名()&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><ul><li><p>新建(New)：新建一个线程对象</p></li><li><p>可运行(Runable)<br>其他线程调用该线程的start()方法。不能对同一线程对象两次调用start()方法。<br>该线程位于可运行线程池中，等待获取cpu使用权。</p></li><li><p>运行(running)：获取了cpu使用权，执行程序代码</p></li><li><p>阻塞(block)：因某种原因[]放弃了cpu使用权，暂时停止运行。直到线程再次进入可运行状态才有可能获取cpu使用权，转为运行状态。</p><ul><li>等待阻塞：执行了wait()方法。jvm把线程放入等待队列，释放锁。被notify(), notifyAll()进入锁池中</li><li>同步阻塞：获取同步锁时，该锁被别的线程占用。jvm把线程放入锁池中</li><li>其他阻塞：执行sleep(毫秒)、join方法、或者发出I/O请求。不释放锁</li></ul></li><li><p>死亡(dead)：线程执行完成或因异常退出，该线程结束生命周期。<font color="pink">死亡的线程不可再次恢复</font>。<br><img src="20191108212300630.png" alt="多线程"></p></li></ul></div><footer class="article-footer"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul><div style="text-align:center;color:#ccc;font-size:14px;margin-top:10px"> ------------- 本文结束&nbsp;<i class="fe fe-smile"></i>&nbsp;感谢您的阅读 -------------</div></footer></div><nav class="article-nav"> <a href="/2019/11/18/JAVA多线程-Object-wait-，Object-notify-，Object-notifyAll/" class="article-nav-link"><strong class="article-nav-caption">前一篇</strong><div class="article-nav-title"> JAVA多线程-Object.wait()，Object.notify()，Object.notifyAll()</div></a> <a href="/2019/11/01/Docker，Docker-Compose，Docker-Swarm，Kubernetes-k8s-之间的区别/" class="article-nav-link"><strong class="article-nav-caption">后一篇</strong><div class="article-nav-title">【转载】Docker，Docker Compose，Docker Swarm，Kubernetes(k8s)之间的区别</div></a></nav><div class="comment_headling" style="margin-top:5rem"><font size="5"><i class="fe fe-comments"></i> 评论</font></div><div class="comment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/js/Valine.min.js"></script><script type="text/javascript">GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),guest_info=0==guest_info.length?GUEST_INFO:guest_info,new Valine({av:AV,el:".comment",app_id:"fq4O7Xaf1cYDbADGellNEn6V-gzGzoHsz",app_key:"a626rNIHkVVk8tGBBCfaQjb9",placeholder:"记得留下你的昵称和邮箱...可以快速收到回复ヾﾉ≧∀≦)o",meta:guest_info,notify:!0,verify:!1,avatar:"monsterid",recordIP:!0,visitor:!1,lang:"zh-cn"})</script></article></section><footer class="footer"><div class="outer"><ul class="list-inline"><li>已分享 48 篇博文，累计 <span class="post-count">55.1k</span> 字</li><ul class="list-inline"><li><i class="fe fe-smile-alt"></i>&nbsp;访客数&emsp;<span id="busuanzi_value_site_uv"></span></li><li><i class="fe fe-bookmark"></i>&nbsp;文章访问量&emsp;<span id="busuanzi_value_page_pv"></span></li></ul></ul><ul class="list-inline"><li><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></li><script>var now=new Date;function createtime(){var n=new Date("07/28/2019 10:02:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="已等候你 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><ul class="list-inline"><li>&copy; 2019-2020 松林羊</li><li>Theme <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li></ul></ul></div></footer></main><aside class="sidebar sidebar-specter"> <button class="navbar-toggle"></button><nav class="navbar"><div class="logo"> <a href="/"><img id="andus-head-img" src="/images/head-nav.png" alt="松林羊"></a></div><ul class="nav nav-main"><li class="nav-item"> <a class="nav-item-link" href="/" target="_self">主页</a></li><li class="nav-item"> <a class="nav-item-link" href="/archives" target="_self">归档</a></li><li class="nav-item"> <a class="nav-item-link" href="/categories" target="_self">分类</a></li><li class="nav-item"> <a class="nav-item-link" href="/tags" target="_self">标签</a></li><li class="nav-item"> <a class="nav-item-link" href="/links" target="_self">友链</a></li><li class="nav-item"> <a class="nav-item-link">综合</a><ul class="nav nav-main nav2"><li class="nav-item li2"> <a class="nav-item-link-child" href="/resource" target="_self">资 源</a></li><li class="nav-item li2"> <a class="nav-item-link-child" href="/site" target="_self">网 站</a></li></ul></li><li class="nav-item"> <a class="nav-item-link">关于</a><ul class="nav nav-main nav2"><li class="nav-item li2"> <a class="nav-item-link-child" href="/me" target="_self">博 主</a></li><li class="nav-item li2"> <a class="nav-item-link-child" href="http://stars.andus.top/" target="_blank">记 录</a></li><li class="nav-item li2"> <a class="nav-item-link-child" href="/plan" target="_self">计 划</a></li></ul></li><li class="nav-item"> <a class="nav-item-link" href="http://resume.andus.top/" target="_blank">简 历</a></li><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="fe fe-search"></i> 搜索</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><div class="totop" id="totop"><i class="fe fe-rocket"></i></div></li><li class="nav-item"></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"> <input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.justifiedGallery.min.js"></script><script src="/js/lazyload.min.js"></script><script src="/js/busuanzi-2.3.pure.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/tocbot.min.js"></script><script>900<=document.body.clientWidth&&tocbot.init({tocSelector:".tocbot",contentSelector:".article-entry",headingSelector:"h1, h2, h3, h4, h5, h6",hasInnerContainers:!0,scrollSmooth:!0,positionFixedSelector:".tocbot",positionFixedClass:"is-position-fixed",fixedSidebarOffset:"auto"})</script><script src="/js/ocean.js"></script><script src="/js/andus.js"></script><script src="/js/love.js"></script><script>$("img:not(#andus-head-img)").each(function(){$(this).wrap('<a class="fancybox" data-fancybox="gallery" href="'+$(this).prop("src")+'"></a>')})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"/live2dw/assets/haruto.model.json"},display:{superSample:2,width:150,height:300,position:"left",hOffset:0,vOffset:-20},mobile:{show:!1},react:{opacityDefault:.5,opacityOnHover:.2},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body>